module Telnyx
  module Models
    type call_hangup_webhook_event =
      { data: Telnyx::CallHangupWebhookEvent::Data }

    class CallHangupWebhookEvent < Telnyx::Internal::Type::BaseModel
      attr_reader data: Telnyx::CallHangupWebhookEvent::Data?

      def data=: (
        Telnyx::CallHangupWebhookEvent::Data
      ) -> Telnyx::CallHangupWebhookEvent::Data

      def initialize: (?data: Telnyx::CallHangupWebhookEvent::Data) -> void

      def to_hash: -> { data: Telnyx::CallHangupWebhookEvent::Data }

      type data =
        {
          id: String,
          event_type: Telnyx::Models::CallHangupWebhookEvent::Data::event_type,
          occurred_at: Time,
          payload: Telnyx::CallHangupWebhookEvent::Data::Payload,
          record_type: Telnyx::Models::CallHangupWebhookEvent::Data::record_type
        }

      class Data < Telnyx::Internal::Type::BaseModel
        attr_reader id: String?

        def id=: (String) -> String

        attr_reader event_type: Telnyx::Models::CallHangupWebhookEvent::Data::event_type?

        def event_type=: (
          Telnyx::Models::CallHangupWebhookEvent::Data::event_type
        ) -> Telnyx::Models::CallHangupWebhookEvent::Data::event_type

        attr_reader occurred_at: Time?

        def occurred_at=: (Time) -> Time

        attr_reader payload: Telnyx::CallHangupWebhookEvent::Data::Payload?

        def payload=: (
          Telnyx::CallHangupWebhookEvent::Data::Payload
        ) -> Telnyx::CallHangupWebhookEvent::Data::Payload

        attr_reader record_type: Telnyx::Models::CallHangupWebhookEvent::Data::record_type?

        def record_type=: (
          Telnyx::Models::CallHangupWebhookEvent::Data::record_type
        ) -> Telnyx::Models::CallHangupWebhookEvent::Data::record_type

        def initialize: (
          ?id: String,
          ?event_type: Telnyx::Models::CallHangupWebhookEvent::Data::event_type,
          ?occurred_at: Time,
          ?payload: Telnyx::CallHangupWebhookEvent::Data::Payload,
          ?record_type: Telnyx::Models::CallHangupWebhookEvent::Data::record_type
        ) -> void

        def to_hash: -> {
          id: String,
          event_type: Telnyx::Models::CallHangupWebhookEvent::Data::event_type,
          occurred_at: Time,
          payload: Telnyx::CallHangupWebhookEvent::Data::Payload,
          record_type: Telnyx::Models::CallHangupWebhookEvent::Data::record_type
        }

        type event_type = :"call.hangup"

        module EventType
          extend Telnyx::Internal::Type::Enum

          CALL_HANGUP: :"call.hangup"

          def self?.values: -> ::Array[Telnyx::Models::CallHangupWebhookEvent::Data::event_type]
        end

        type payload =
          {
            call_control_id: String,
            call_leg_id: String,
            call_quality_stats: Telnyx::CallHangupWebhookEvent::Data::Payload::CallQualityStats?,
            call_session_id: String,
            client_state: String,
            connection_id: String,
            custom_headers: ::Array[Telnyx::CustomSipHeader],
            from: String,
            hangup_cause: Telnyx::Models::CallHangupWebhookEvent::Data::Payload::hangup_cause,
            hangup_source: Telnyx::Models::CallHangupWebhookEvent::Data::Payload::hangup_source,
            sip_hangup_cause: String,
            sip_headers: ::Array[Telnyx::SipHeader],
            start_time: Time,
            state: Telnyx::Models::CallHangupWebhookEvent::Data::Payload::state,
            tags: ::Array[String],
            to: String
          }

        class Payload < Telnyx::Internal::Type::BaseModel
          attr_reader call_control_id: String?

          def call_control_id=: (String) -> String

          attr_reader call_leg_id: String?

          def call_leg_id=: (String) -> String

          attr_accessor call_quality_stats: Telnyx::CallHangupWebhookEvent::Data::Payload::CallQualityStats?

          attr_reader call_session_id: String?

          def call_session_id=: (String) -> String

          attr_reader client_state: String?

          def client_state=: (String) -> String

          attr_reader connection_id: String?

          def connection_id=: (String) -> String

          attr_reader custom_headers: ::Array[Telnyx::CustomSipHeader]?

          def custom_headers=: (
            ::Array[Telnyx::CustomSipHeader]
          ) -> ::Array[Telnyx::CustomSipHeader]

          attr_reader from: String?

          def from=: (String) -> String

          attr_reader hangup_cause: Telnyx::Models::CallHangupWebhookEvent::Data::Payload::hangup_cause?

          def hangup_cause=: (
            Telnyx::Models::CallHangupWebhookEvent::Data::Payload::hangup_cause
          ) -> Telnyx::Models::CallHangupWebhookEvent::Data::Payload::hangup_cause

          attr_reader hangup_source: Telnyx::Models::CallHangupWebhookEvent::Data::Payload::hangup_source?

          def hangup_source=: (
            Telnyx::Models::CallHangupWebhookEvent::Data::Payload::hangup_source
          ) -> Telnyx::Models::CallHangupWebhookEvent::Data::Payload::hangup_source

          attr_reader sip_hangup_cause: String?

          def sip_hangup_cause=: (String) -> String

          attr_reader sip_headers: ::Array[Telnyx::SipHeader]?

          def sip_headers=: (
            ::Array[Telnyx::SipHeader]
          ) -> ::Array[Telnyx::SipHeader]

          attr_reader start_time: Time?

          def start_time=: (Time) -> Time

          attr_reader state: Telnyx::Models::CallHangupWebhookEvent::Data::Payload::state?

          def state=: (
            Telnyx::Models::CallHangupWebhookEvent::Data::Payload::state
          ) -> Telnyx::Models::CallHangupWebhookEvent::Data::Payload::state

          attr_reader tags: ::Array[String]?

          def tags=: (::Array[String]) -> ::Array[String]

          attr_reader to: String?

          def to=: (String) -> String

          def initialize: (
            ?call_control_id: String,
            ?call_leg_id: String,
            ?call_quality_stats: Telnyx::CallHangupWebhookEvent::Data::Payload::CallQualityStats?,
            ?call_session_id: String,
            ?client_state: String,
            ?connection_id: String,
            ?custom_headers: ::Array[Telnyx::CustomSipHeader],
            ?from: String,
            ?hangup_cause: Telnyx::Models::CallHangupWebhookEvent::Data::Payload::hangup_cause,
            ?hangup_source: Telnyx::Models::CallHangupWebhookEvent::Data::Payload::hangup_source,
            ?sip_hangup_cause: String,
            ?sip_headers: ::Array[Telnyx::SipHeader],
            ?start_time: Time,
            ?state: Telnyx::Models::CallHangupWebhookEvent::Data::Payload::state,
            ?tags: ::Array[String],
            ?to: String
          ) -> void

          def to_hash: -> {
            call_control_id: String,
            call_leg_id: String,
            call_quality_stats: Telnyx::CallHangupWebhookEvent::Data::Payload::CallQualityStats?,
            call_session_id: String,
            client_state: String,
            connection_id: String,
            custom_headers: ::Array[Telnyx::CustomSipHeader],
            from: String,
            hangup_cause: Telnyx::Models::CallHangupWebhookEvent::Data::Payload::hangup_cause,
            hangup_source: Telnyx::Models::CallHangupWebhookEvent::Data::Payload::hangup_source,
            sip_hangup_cause: String,
            sip_headers: ::Array[Telnyx::SipHeader],
            start_time: Time,
            state: Telnyx::Models::CallHangupWebhookEvent::Data::Payload::state,
            tags: ::Array[String],
            to: String
          }

          type call_quality_stats =
            {
              inbound: Telnyx::CallHangupWebhookEvent::Data::Payload::CallQualityStats::Inbound,
              outbound: Telnyx::CallHangupWebhookEvent::Data::Payload::CallQualityStats::Outbound
            }

          class CallQualityStats < Telnyx::Internal::Type::BaseModel
            attr_reader inbound: Telnyx::CallHangupWebhookEvent::Data::Payload::CallQualityStats::Inbound?

            def inbound=: (
              Telnyx::CallHangupWebhookEvent::Data::Payload::CallQualityStats::Inbound
            ) -> Telnyx::CallHangupWebhookEvent::Data::Payload::CallQualityStats::Inbound

            attr_reader outbound: Telnyx::CallHangupWebhookEvent::Data::Payload::CallQualityStats::Outbound?

            def outbound=: (
              Telnyx::CallHangupWebhookEvent::Data::Payload::CallQualityStats::Outbound
            ) -> Telnyx::CallHangupWebhookEvent::Data::Payload::CallQualityStats::Outbound

            def initialize: (
              ?inbound: Telnyx::CallHangupWebhookEvent::Data::Payload::CallQualityStats::Inbound,
              ?outbound: Telnyx::CallHangupWebhookEvent::Data::Payload::CallQualityStats::Outbound
            ) -> void

            def to_hash: -> {
              inbound: Telnyx::CallHangupWebhookEvent::Data::Payload::CallQualityStats::Inbound,
              outbound: Telnyx::CallHangupWebhookEvent::Data::Payload::CallQualityStats::Outbound
            }

            type inbound =
              {
                jitter_max_variance: String,
                jitter_packet_count: String,
                mos: String,
                packet_count: String,
                skip_packet_count: String
              }

            class Inbound < Telnyx::Internal::Type::BaseModel
              attr_reader jitter_max_variance: String?

              def jitter_max_variance=: (String) -> String

              attr_reader jitter_packet_count: String?

              def jitter_packet_count=: (String) -> String

              attr_reader mos: String?

              def mos=: (String) -> String

              attr_reader packet_count: String?

              def packet_count=: (String) -> String

              attr_reader skip_packet_count: String?

              def skip_packet_count=: (String) -> String

              def initialize: (
                ?jitter_max_variance: String,
                ?jitter_packet_count: String,
                ?mos: String,
                ?packet_count: String,
                ?skip_packet_count: String
              ) -> void

              def to_hash: -> {
                jitter_max_variance: String,
                jitter_packet_count: String,
                mos: String,
                packet_count: String,
                skip_packet_count: String
              }
            end

            type outbound = { packet_count: String, skip_packet_count: String }

            class Outbound < Telnyx::Internal::Type::BaseModel
              attr_reader packet_count: String?

              def packet_count=: (String) -> String

              attr_reader skip_packet_count: String?

              def skip_packet_count=: (String) -> String

              def initialize: (
                ?packet_count: String,
                ?skip_packet_count: String
              ) -> void

              def to_hash: -> {
                packet_count: String,
                skip_packet_count: String
              }
            end
          end

          type hangup_cause =
            :call_rejected
            | :normal_clearing
            | :originator_cancel
            | :timeout
            | :time_limit
            | :user_busy
            | :not_found
            | :unspecified

          module HangupCause
            extend Telnyx::Internal::Type::Enum

            CALL_REJECTED: :call_rejected
            NORMAL_CLEARING: :normal_clearing
            ORIGINATOR_CANCEL: :originator_cancel
            TIMEOUT: :timeout
            TIME_LIMIT: :time_limit
            USER_BUSY: :user_busy
            NOT_FOUND: :not_found
            UNSPECIFIED: :unspecified

            def self?.values: -> ::Array[Telnyx::Models::CallHangupWebhookEvent::Data::Payload::hangup_cause]
          end

          type hangup_source = :caller | :callee | :unknown

          module HangupSource
            extend Telnyx::Internal::Type::Enum

            CALLER: :caller
            CALLEE: :callee
            UNKNOWN: :unknown

            def self?.values: -> ::Array[Telnyx::Models::CallHangupWebhookEvent::Data::Payload::hangup_source]
          end

          type state = :hangup

          module State
            extend Telnyx::Internal::Type::Enum

            HANGUP: :hangup

            def self?.values: -> ::Array[Telnyx::Models::CallHangupWebhookEvent::Data::Payload::state]
          end
        end

        type record_type = :event

        module RecordType
          extend Telnyx::Internal::Type::Enum

          EVENT: :event

          def self?.values: -> ::Array[Telnyx::Models::CallHangupWebhookEvent::Data::record_type]
        end
      end
    end
  end
end
