module Telnyx
  module Models
    class MdrUsageReport = Reports::MdrUsageReport

    module Reports
      type mdr_usage_report =
        {
          id: String,
          aggregation_type: Telnyx::Models::Reports::MdrUsageReport::aggregation_type,
          connections: ::Array[Integer],
          created_at: Time,
          end_date: Time,
          profiles: String,
          record_type: String,
          report_url: String,
          result: ::Array[Telnyx::Reports::MdrUsageReport::Result],
          start_date: Time,
          status: Telnyx::Models::Reports::MdrUsageReport::status,
          updated_at: Time
        }

      class MdrUsageReport < Telnyx::Internal::Type::BaseModel
        attr_reader id: String?

        def id=: (String) -> String

        attr_reader aggregation_type: Telnyx::Models::Reports::MdrUsageReport::aggregation_type?

        def aggregation_type=: (
          Telnyx::Models::Reports::MdrUsageReport::aggregation_type
        ) -> Telnyx::Models::Reports::MdrUsageReport::aggregation_type

        attr_reader connections: ::Array[Integer]?

        def connections=: (::Array[Integer]) -> ::Array[Integer]

        attr_reader created_at: Time?

        def created_at=: (Time) -> Time

        attr_reader end_date: Time?

        def end_date=: (Time) -> Time

        attr_reader profiles: String?

        def profiles=: (String) -> String

        attr_reader record_type: String?

        def record_type=: (String) -> String

        attr_reader report_url: String?

        def report_url=: (String) -> String

        attr_reader result: ::Array[Telnyx::Reports::MdrUsageReport::Result]?

        def result=: (
          ::Array[Telnyx::Reports::MdrUsageReport::Result]
        ) -> ::Array[Telnyx::Reports::MdrUsageReport::Result]

        attr_reader start_date: Time?

        def start_date=: (Time) -> Time

        attr_reader status: Telnyx::Models::Reports::MdrUsageReport::status?

        def status=: (
          Telnyx::Models::Reports::MdrUsageReport::status
        ) -> Telnyx::Models::Reports::MdrUsageReport::status

        attr_reader updated_at: Time?

        def updated_at=: (Time) -> Time

        def initialize: (
          ?id: String,
          ?aggregation_type: Telnyx::Models::Reports::MdrUsageReport::aggregation_type,
          ?connections: ::Array[Integer],
          ?created_at: Time,
          ?end_date: Time,
          ?profiles: String,
          ?record_type: String,
          ?report_url: String,
          ?result: ::Array[Telnyx::Reports::MdrUsageReport::Result],
          ?start_date: Time,
          ?status: Telnyx::Models::Reports::MdrUsageReport::status,
          ?updated_at: Time
        ) -> void

        def to_hash: -> {
          id: String,
          aggregation_type: Telnyx::Models::Reports::MdrUsageReport::aggregation_type,
          connections: ::Array[Integer],
          created_at: Time,
          end_date: Time,
          profiles: String,
          record_type: String,
          report_url: String,
          result: ::Array[Telnyx::Reports::MdrUsageReport::Result],
          start_date: Time,
          status: Telnyx::Models::Reports::MdrUsageReport::status,
          updated_at: Time
        }

        type aggregation_type = :NO_AGGREGATION | :PROFILE | :TAGS

        module AggregationType
          extend Telnyx::Internal::Type::Enum

          NO_AGGREGATION: :NO_AGGREGATION
          PROFILE: :PROFILE
          TAGS: :TAGS

          def self?.values: -> ::Array[Telnyx::Models::Reports::MdrUsageReport::aggregation_type]
        end

        type result =
          {
            carrier_passthrough_fee: String,
            connection: String,
            cost: String,
            currency: String,
            delivered: String,
            direction: String,
            message_type: String,
            parts: String,
            product: String,
            profile_id: String,
            received: String,
            sent: String,
            tags: String,
            tn_type: String
          }

        class Result < Telnyx::Internal::Type::BaseModel
          attr_reader carrier_passthrough_fee: String?

          def carrier_passthrough_fee=: (String) -> String

          attr_reader connection: String?

          def connection=: (String) -> String

          attr_reader cost: String?

          def cost=: (String) -> String

          attr_reader currency: String?

          def currency=: (String) -> String

          attr_reader delivered: String?

          def delivered=: (String) -> String

          attr_reader direction: String?

          def direction=: (String) -> String

          attr_reader message_type: String?

          def message_type=: (String) -> String

          attr_reader parts: String?

          def parts=: (String) -> String

          attr_reader product: String?

          def product=: (String) -> String

          attr_reader profile_id: String?

          def profile_id=: (String) -> String

          attr_reader received: String?

          def received=: (String) -> String

          attr_reader sent: String?

          def sent=: (String) -> String

          attr_reader tags: String?

          def tags=: (String) -> String

          attr_reader tn_type: String?

          def tn_type=: (String) -> String

          def initialize: (
            ?carrier_passthrough_fee: String,
            ?connection: String,
            ?cost: String,
            ?currency: String,
            ?delivered: String,
            ?direction: String,
            ?message_type: String,
            ?parts: String,
            ?product: String,
            ?profile_id: String,
            ?received: String,
            ?sent: String,
            ?tags: String,
            ?tn_type: String
          ) -> void

          def to_hash: -> {
            carrier_passthrough_fee: String,
            connection: String,
            cost: String,
            currency: String,
            delivered: String,
            direction: String,
            message_type: String,
            parts: String,
            product: String,
            profile_id: String,
            received: String,
            sent: String,
            tags: String,
            tn_type: String
          }
        end

        type status = :PENDING | :COMPLETE | :FAILED | :EXPIRED

        module Status
          extend Telnyx::Internal::Type::Enum

          PENDING: :PENDING
          COMPLETE: :COMPLETE
          FAILED: :FAILED
          EXPIRED: :EXPIRED

          def self?.values: -> ::Array[Telnyx::Models::Reports::MdrUsageReport::status]
        end
      end
    end
  end
end
