module Telnyx
  module Models
    type inbound_message_payload =
      {
        id: String,
        cc: ::Array[Telnyx::InboundMessagePayload::Cc],
        completed_at: Time?,
        cost: Telnyx::InboundMessagePayload::Cost?,
        cost_breakdown: Telnyx::InboundMessagePayload::CostBreakdown?,
        direction: Telnyx::Models::InboundMessagePayload::direction,
        encoding: String,
        errors: ::Array[Telnyx::MessagingError],
        from: Telnyx::InboundMessagePayload::From,
        media: ::Array[Telnyx::InboundMessagePayload::Media],
        messaging_profile_id: String,
        organization_id: String,
        parts: Integer,
        received_at: Time,
        record_type: Telnyx::Models::InboundMessagePayload::record_type,
        sent_at: Time?,
        subject: String?,
        tags: ::Array[String],
        tcr_campaign_billable: bool,
        tcr_campaign_id: String?,
        tcr_campaign_registered: String?,
        text: String,
        to: ::Array[Telnyx::InboundMessagePayload::To],
        type: Telnyx::Models::InboundMessagePayload::type_,
        valid_until: Time?,
        webhook_failover_url: String?,
        webhook_url: String?
      }

    class InboundMessagePayload < Telnyx::Internal::Type::BaseModel
      attr_reader id: String?

      def id=: (String) -> String

      attr_reader cc: ::Array[Telnyx::InboundMessagePayload::Cc]?

      def cc=: (
        ::Array[Telnyx::InboundMessagePayload::Cc]
      ) -> ::Array[Telnyx::InboundMessagePayload::Cc]

      attr_accessor completed_at: Time?

      attr_accessor cost: Telnyx::InboundMessagePayload::Cost?

      attr_accessor cost_breakdown: Telnyx::InboundMessagePayload::CostBreakdown?

      attr_reader direction: Telnyx::Models::InboundMessagePayload::direction?

      def direction=: (
        Telnyx::Models::InboundMessagePayload::direction
      ) -> Telnyx::Models::InboundMessagePayload::direction

      attr_reader encoding: String?

      def encoding=: (String) -> String

      attr_reader errors: ::Array[Telnyx::MessagingError]?

      def errors=: (
        ::Array[Telnyx::MessagingError]
      ) -> ::Array[Telnyx::MessagingError]

      attr_reader from: Telnyx::InboundMessagePayload::From?

      def from=: (
        Telnyx::InboundMessagePayload::From
      ) -> Telnyx::InboundMessagePayload::From

      attr_reader media: ::Array[Telnyx::InboundMessagePayload::Media]?

      def media=: (
        ::Array[Telnyx::InboundMessagePayload::Media]
      ) -> ::Array[Telnyx::InboundMessagePayload::Media]

      attr_reader messaging_profile_id: String?

      def messaging_profile_id=: (String) -> String

      attr_reader organization_id: String?

      def organization_id=: (String) -> String

      attr_reader parts: Integer?

      def parts=: (Integer) -> Integer

      attr_reader received_at: Time?

      def received_at=: (Time) -> Time

      attr_reader record_type: Telnyx::Models::InboundMessagePayload::record_type?

      def record_type=: (
        Telnyx::Models::InboundMessagePayload::record_type
      ) -> Telnyx::Models::InboundMessagePayload::record_type

      attr_accessor sent_at: Time?

      attr_accessor subject: String?

      attr_reader tags: ::Array[String]?

      def tags=: (::Array[String]) -> ::Array[String]

      attr_reader tcr_campaign_billable: bool?

      def tcr_campaign_billable=: (bool) -> bool

      attr_accessor tcr_campaign_id: String?

      attr_accessor tcr_campaign_registered: String?

      attr_reader text: String?

      def text=: (String) -> String

      attr_reader to: ::Array[Telnyx::InboundMessagePayload::To]?

      def to=: (
        ::Array[Telnyx::InboundMessagePayload::To]
      ) -> ::Array[Telnyx::InboundMessagePayload::To]

      attr_reader type: Telnyx::Models::InboundMessagePayload::type_?

      def type=: (
        Telnyx::Models::InboundMessagePayload::type_
      ) -> Telnyx::Models::InboundMessagePayload::type_

      attr_accessor valid_until: Time?

      attr_accessor webhook_failover_url: String?

      attr_accessor webhook_url: String?

      def initialize: (
        ?id: String,
        ?cc: ::Array[Telnyx::InboundMessagePayload::Cc],
        ?completed_at: Time?,
        ?cost: Telnyx::InboundMessagePayload::Cost?,
        ?cost_breakdown: Telnyx::InboundMessagePayload::CostBreakdown?,
        ?direction: Telnyx::Models::InboundMessagePayload::direction,
        ?encoding: String,
        ?errors: ::Array[Telnyx::MessagingError],
        ?from: Telnyx::InboundMessagePayload::From,
        ?media: ::Array[Telnyx::InboundMessagePayload::Media],
        ?messaging_profile_id: String,
        ?organization_id: String,
        ?parts: Integer,
        ?received_at: Time,
        ?record_type: Telnyx::Models::InboundMessagePayload::record_type,
        ?sent_at: Time?,
        ?subject: String?,
        ?tags: ::Array[String],
        ?tcr_campaign_billable: bool,
        ?tcr_campaign_id: String?,
        ?tcr_campaign_registered: String?,
        ?text: String,
        ?to: ::Array[Telnyx::InboundMessagePayload::To],
        ?type: Telnyx::Models::InboundMessagePayload::type_,
        ?valid_until: Time?,
        ?webhook_failover_url: String?,
        ?webhook_url: String?
      ) -> void

      def to_hash: -> {
        id: String,
        cc: ::Array[Telnyx::InboundMessagePayload::Cc],
        completed_at: Time?,
        cost: Telnyx::InboundMessagePayload::Cost?,
        cost_breakdown: Telnyx::InboundMessagePayload::CostBreakdown?,
        direction: Telnyx::Models::InboundMessagePayload::direction,
        encoding: String,
        errors: ::Array[Telnyx::MessagingError],
        from: Telnyx::InboundMessagePayload::From,
        media: ::Array[Telnyx::InboundMessagePayload::Media],
        messaging_profile_id: String,
        organization_id: String,
        parts: Integer,
        received_at: Time,
        record_type: Telnyx::Models::InboundMessagePayload::record_type,
        sent_at: Time?,
        subject: String?,
        tags: ::Array[String],
        tcr_campaign_billable: bool,
        tcr_campaign_id: String?,
        tcr_campaign_registered: String?,
        text: String,
        to: ::Array[Telnyx::InboundMessagePayload::To],
        type: Telnyx::Models::InboundMessagePayload::type_,
        valid_until: Time?,
        webhook_failover_url: String?,
        webhook_url: String?
      }

      type cc =
        {
          carrier: String,
          line_type: Telnyx::Models::InboundMessagePayload::Cc::line_type,
          phone_number: String,
          status: Telnyx::Models::InboundMessagePayload::Cc::status
        }

      class Cc < Telnyx::Internal::Type::BaseModel
        attr_reader carrier: String?

        def carrier=: (String) -> String

        attr_reader line_type: Telnyx::Models::InboundMessagePayload::Cc::line_type?

        def line_type=: (
          Telnyx::Models::InboundMessagePayload::Cc::line_type
        ) -> Telnyx::Models::InboundMessagePayload::Cc::line_type

        attr_reader phone_number: String?

        def phone_number=: (String) -> String

        attr_reader status: Telnyx::Models::InboundMessagePayload::Cc::status?

        def status=: (
          Telnyx::Models::InboundMessagePayload::Cc::status
        ) -> Telnyx::Models::InboundMessagePayload::Cc::status

        def initialize: (
          ?carrier: String,
          ?line_type: Telnyx::Models::InboundMessagePayload::Cc::line_type,
          ?phone_number: String,
          ?status: Telnyx::Models::InboundMessagePayload::Cc::status
        ) -> void

        def to_hash: -> {
          carrier: String,
          line_type: Telnyx::Models::InboundMessagePayload::Cc::line_type,
          phone_number: String,
          status: Telnyx::Models::InboundMessagePayload::Cc::status
        }

        type line_type =
          :Wireline | :Wireless | :VoWiFi | :VoIP | :"Pre-Paid Wireless" | :""

        module LineType
          extend Telnyx::Internal::Type::Enum

          WIRELINE: :Wireline
          WIRELESS: :Wireless
          VO_WI_FI: :VoWiFi
          VO_IP: :VoIP
          PRE_PAID_WIRELESS: :"Pre-Paid Wireless"
          EMPTY: :""

          def self?.values: -> ::Array[Telnyx::Models::InboundMessagePayload::Cc::line_type]
        end

        type status =
          :queued
          | :sending
          | :sent
          | :delivered
          | :sending_failed
          | :delivery_failed
          | :delivery_unconfirmed

        module Status
          extend Telnyx::Internal::Type::Enum

          QUEUED: :queued
          SENDING: :sending
          SENT: :sent
          DELIVERED: :delivered
          SENDING_FAILED: :sending_failed
          DELIVERY_FAILED: :delivery_failed
          DELIVERY_UNCONFIRMED: :delivery_unconfirmed

          def self?.values: -> ::Array[Telnyx::Models::InboundMessagePayload::Cc::status]
        end
      end

      type cost = { amount: String, currency: String }

      class Cost < Telnyx::Internal::Type::BaseModel
        attr_reader amount: String?

        def amount=: (String) -> String

        attr_reader currency: String?

        def currency=: (String) -> String

        def initialize: (?amount: String, ?currency: String) -> void

        def to_hash: -> { amount: String, currency: String }
      end

      type cost_breakdown =
        {
          carrier_fee: Telnyx::InboundMessagePayload::CostBreakdown::CarrierFee,
          rate: Telnyx::InboundMessagePayload::CostBreakdown::Rate
        }

      class CostBreakdown < Telnyx::Internal::Type::BaseModel
        attr_reader carrier_fee: Telnyx::InboundMessagePayload::CostBreakdown::CarrierFee?

        def carrier_fee=: (
          Telnyx::InboundMessagePayload::CostBreakdown::CarrierFee
        ) -> Telnyx::InboundMessagePayload::CostBreakdown::CarrierFee

        attr_reader rate: Telnyx::InboundMessagePayload::CostBreakdown::Rate?

        def rate=: (
          Telnyx::InboundMessagePayload::CostBreakdown::Rate
        ) -> Telnyx::InboundMessagePayload::CostBreakdown::Rate

        def initialize: (
          ?carrier_fee: Telnyx::InboundMessagePayload::CostBreakdown::CarrierFee,
          ?rate: Telnyx::InboundMessagePayload::CostBreakdown::Rate
        ) -> void

        def to_hash: -> {
          carrier_fee: Telnyx::InboundMessagePayload::CostBreakdown::CarrierFee,
          rate: Telnyx::InboundMessagePayload::CostBreakdown::Rate
        }

        type carrier_fee = { amount: String, currency: String }

        class CarrierFee < Telnyx::Internal::Type::BaseModel
          attr_reader amount: String?

          def amount=: (String) -> String

          attr_reader currency: String?

          def currency=: (String) -> String

          def initialize: (?amount: String, ?currency: String) -> void

          def to_hash: -> { amount: String, currency: String }
        end

        type rate = { amount: String, currency: String }

        class Rate < Telnyx::Internal::Type::BaseModel
          attr_reader amount: String?

          def amount=: (String) -> String

          attr_reader currency: String?

          def currency=: (String) -> String

          def initialize: (?amount: String, ?currency: String) -> void

          def to_hash: -> { amount: String, currency: String }
        end
      end

      type direction = :inbound

      module Direction
        extend Telnyx::Internal::Type::Enum

        INBOUND: :inbound

        def self?.values: -> ::Array[Telnyx::Models::InboundMessagePayload::direction]
      end

      type from =
        {
          carrier: String,
          line_type: Telnyx::Models::InboundMessagePayload::From::line_type,
          phone_number: String,
          status: Telnyx::Models::InboundMessagePayload::From::status
        }

      class From < Telnyx::Internal::Type::BaseModel
        attr_reader carrier: String?

        def carrier=: (String) -> String

        attr_reader line_type: Telnyx::Models::InboundMessagePayload::From::line_type?

        def line_type=: (
          Telnyx::Models::InboundMessagePayload::From::line_type
        ) -> Telnyx::Models::InboundMessagePayload::From::line_type

        attr_reader phone_number: String?

        def phone_number=: (String) -> String

        attr_reader status: Telnyx::Models::InboundMessagePayload::From::status?

        def status=: (
          Telnyx::Models::InboundMessagePayload::From::status
        ) -> Telnyx::Models::InboundMessagePayload::From::status

        def initialize: (
          ?carrier: String,
          ?line_type: Telnyx::Models::InboundMessagePayload::From::line_type,
          ?phone_number: String,
          ?status: Telnyx::Models::InboundMessagePayload::From::status
        ) -> void

        def to_hash: -> {
          carrier: String,
          line_type: Telnyx::Models::InboundMessagePayload::From::line_type,
          phone_number: String,
          status: Telnyx::Models::InboundMessagePayload::From::status
        }

        type line_type =
          :Wireline | :Wireless | :VoWiFi | :VoIP | :"Pre-Paid Wireless" | :""

        module LineType
          extend Telnyx::Internal::Type::Enum

          WIRELINE: :Wireline
          WIRELESS: :Wireless
          VO_WI_FI: :VoWiFi
          VO_IP: :VoIP
          PRE_PAID_WIRELESS: :"Pre-Paid Wireless"
          EMPTY: :""

          def self?.values: -> ::Array[Telnyx::Models::InboundMessagePayload::From::line_type]
        end

        type status = :received | :delivered

        module Status
          extend Telnyx::Internal::Type::Enum

          RECEIVED: :received
          DELIVERED: :delivered

          def self?.values: -> ::Array[Telnyx::Models::InboundMessagePayload::From::status]
        end
      end

      type media =
        {
          content_type: String,
          :hash_sha256 => String,
          size: Integer,
          url: String
        }

      class Media < Telnyx::Internal::Type::BaseModel
        attr_reader content_type: String?

        def content_type=: (String) -> String

        attr_reader hash_sha256: String?

        def hash_sha256=: (String) -> String

        attr_reader size: Integer?

        def size=: (Integer) -> Integer

        attr_reader url: String?

        def url=: (String) -> String

        def initialize: (
          ?content_type: String,
          ?hash_sha256: String,
          ?size: Integer,
          ?url: String
        ) -> void

        def to_hash: -> {
          content_type: String,
          :hash_sha256 => String,
          size: Integer,
          url: String
        }
      end

      type record_type = :message

      module RecordType
        extend Telnyx::Internal::Type::Enum

        MESSAGE: :message

        def self?.values: -> ::Array[Telnyx::Models::InboundMessagePayload::record_type]
      end

      type to =
        {
          carrier: String,
          line_type: Telnyx::Models::InboundMessagePayload::To::line_type,
          phone_number: String,
          status: Telnyx::Models::InboundMessagePayload::To::status
        }

      class To < Telnyx::Internal::Type::BaseModel
        attr_reader carrier: String?

        def carrier=: (String) -> String

        attr_reader line_type: Telnyx::Models::InboundMessagePayload::To::line_type?

        def line_type=: (
          Telnyx::Models::InboundMessagePayload::To::line_type
        ) -> Telnyx::Models::InboundMessagePayload::To::line_type

        attr_reader phone_number: String?

        def phone_number=: (String) -> String

        attr_reader status: Telnyx::Models::InboundMessagePayload::To::status?

        def status=: (
          Telnyx::Models::InboundMessagePayload::To::status
        ) -> Telnyx::Models::InboundMessagePayload::To::status

        def initialize: (
          ?carrier: String,
          ?line_type: Telnyx::Models::InboundMessagePayload::To::line_type,
          ?phone_number: String,
          ?status: Telnyx::Models::InboundMessagePayload::To::status
        ) -> void

        def to_hash: -> {
          carrier: String,
          line_type: Telnyx::Models::InboundMessagePayload::To::line_type,
          phone_number: String,
          status: Telnyx::Models::InboundMessagePayload::To::status
        }

        type line_type =
          :Wireline | :Wireless | :VoWiFi | :VoIP | :"Pre-Paid Wireless" | :""

        module LineType
          extend Telnyx::Internal::Type::Enum

          WIRELINE: :Wireline
          WIRELESS: :Wireless
          VO_WI_FI: :VoWiFi
          VO_IP: :VoIP
          PRE_PAID_WIRELESS: :"Pre-Paid Wireless"
          EMPTY: :""

          def self?.values: -> ::Array[Telnyx::Models::InboundMessagePayload::To::line_type]
        end

        type status =
          :queued
          | :sending
          | :sent
          | :delivered
          | :sending_failed
          | :delivery_failed
          | :delivery_unconfirmed
          | :webhook_delivered

        module Status
          extend Telnyx::Internal::Type::Enum

          QUEUED: :queued
          SENDING: :sending
          SENT: :sent
          DELIVERED: :delivered
          SENDING_FAILED: :sending_failed
          DELIVERY_FAILED: :delivery_failed
          DELIVERY_UNCONFIRMED: :delivery_unconfirmed
          WEBHOOK_DELIVERED: :webhook_delivered

          def self?.values: -> ::Array[Telnyx::Models::InboundMessagePayload::To::status]
        end
      end

      type type_ = :SMS | :MMS

      module Type
        extend Telnyx::Internal::Type::Enum

        SMS: :SMS
        MMS: :MMS

        def self?.values: -> ::Array[Telnyx::Models::InboundMessagePayload::type_]
      end
    end
  end
end
