module Telnyx
  module Models
    module Porting
      type event_list_response =
        Telnyx::Models::Porting::EventListResponse::PortingEventDeletedPayload
        | Telnyx::Models::Porting::EventListResponse::PortingEventMessagingChangedPayload
        | Telnyx::Models::Porting::EventListResponse::PortingEventStatusChangedEvent
        | Telnyx::Models::Porting::EventListResponse::PortingEventNewCommentEvent
        | Telnyx::Models::Porting::EventListResponse::PortingEventSplitEvent
        | Telnyx::Models::Porting::EventListResponse::PortingEventWithoutWebhook

      module EventListResponse
        extend Telnyx::Internal::Type::Union

        type porting_event_deleted_payload =
          {
            id: String,
            available_notification_methods: ::Array[Telnyx::Models::Porting::EventListResponse::PortingEventDeletedPayload::available_notification_method],
            event_type: Telnyx::Models::Porting::EventListResponse::PortingEventDeletedPayload::event_type,
            payload: Telnyx::Models::Porting::EventListResponse::PortingEventDeletedPayload::Payload,
            payload_status: Telnyx::Models::Porting::EventListResponse::PortingEventDeletedPayload::payload_status,
            porting_order_id: String
          }

        class PortingEventDeletedPayload < Telnyx::Internal::Type::BaseModel
          attr_reader id: String?

          def id=: (String) -> String

          attr_reader available_notification_methods: ::Array[Telnyx::Models::Porting::EventListResponse::PortingEventDeletedPayload::available_notification_method]?

          def available_notification_methods=: (
            ::Array[Telnyx::Models::Porting::EventListResponse::PortingEventDeletedPayload::available_notification_method]
          ) -> ::Array[Telnyx::Models::Porting::EventListResponse::PortingEventDeletedPayload::available_notification_method]

          attr_reader event_type: Telnyx::Models::Porting::EventListResponse::PortingEventDeletedPayload::event_type?

          def event_type=: (
            Telnyx::Models::Porting::EventListResponse::PortingEventDeletedPayload::event_type
          ) -> Telnyx::Models::Porting::EventListResponse::PortingEventDeletedPayload::event_type

          attr_reader payload: Telnyx::Models::Porting::EventListResponse::PortingEventDeletedPayload::Payload?

          def payload=: (
            Telnyx::Models::Porting::EventListResponse::PortingEventDeletedPayload::Payload
          ) -> Telnyx::Models::Porting::EventListResponse::PortingEventDeletedPayload::Payload

          attr_reader payload_status: Telnyx::Models::Porting::EventListResponse::PortingEventDeletedPayload::payload_status?

          def payload_status=: (
            Telnyx::Models::Porting::EventListResponse::PortingEventDeletedPayload::payload_status
          ) -> Telnyx::Models::Porting::EventListResponse::PortingEventDeletedPayload::payload_status

          attr_reader porting_order_id: String?

          def porting_order_id=: (String) -> String

          def initialize: (
            ?id: String,
            ?available_notification_methods: ::Array[Telnyx::Models::Porting::EventListResponse::PortingEventDeletedPayload::available_notification_method],
            ?event_type: Telnyx::Models::Porting::EventListResponse::PortingEventDeletedPayload::event_type,
            ?payload: Telnyx::Models::Porting::EventListResponse::PortingEventDeletedPayload::Payload,
            ?payload_status: Telnyx::Models::Porting::EventListResponse::PortingEventDeletedPayload::payload_status,
            ?porting_order_id: String
          ) -> void

          def to_hash: -> {
            id: String,
            available_notification_methods: ::Array[Telnyx::Models::Porting::EventListResponse::PortingEventDeletedPayload::available_notification_method],
            event_type: Telnyx::Models::Porting::EventListResponse::PortingEventDeletedPayload::event_type,
            payload: Telnyx::Models::Porting::EventListResponse::PortingEventDeletedPayload::Payload,
            payload_status: Telnyx::Models::Porting::EventListResponse::PortingEventDeletedPayload::payload_status,
            porting_order_id: String
          }

          type available_notification_method = :email | :webhook | :webhook_v1

          module AvailableNotificationMethod
            extend Telnyx::Internal::Type::Enum

            EMAIL: :email
            WEBHOOK: :webhook
            WEBHOOK_V1: :webhook_v1

            def self?.values: -> ::Array[Telnyx::Models::Porting::EventListResponse::PortingEventDeletedPayload::available_notification_method]
          end

          type event_type =
            :"porting_order.deleted"
            | :"porting_order.loa_updated"
            | :"porting_order.messaging_changed"
            | :"porting_order.status_changed"
            | :"porting_order.sharing_token_expired"
            | :"porting_order.new_comment"
            | :"porting_order.split"

          module EventType
            extend Telnyx::Internal::Type::Enum

            PORTING_ORDER_DELETED: :"porting_order.deleted"
            PORTING_ORDER_LOA_UPDATED: :"porting_order.loa_updated"
            PORTING_ORDER_MESSAGING_CHANGED: :"porting_order.messaging_changed"
            PORTING_ORDER_STATUS_CHANGED: :"porting_order.status_changed"
            PORTING_ORDER_SHARING_TOKEN_EXPIRED: :"porting_order.sharing_token_expired"
            PORTING_ORDER_NEW_COMMENT: :"porting_order.new_comment"
            PORTING_ORDER_SPLIT: :"porting_order.split"

            def self?.values: -> ::Array[Telnyx::Models::Porting::EventListResponse::PortingEventDeletedPayload::event_type]
          end

          type payload =
            {
              id: String,
              created_at: Time,
              customer_reference: String,
              deleted_at: Time,
              record_type: String,
              updated_at: Time
            }

          class Payload < Telnyx::Internal::Type::BaseModel
            attr_reader id: String?

            def id=: (String) -> String

            attr_reader created_at: Time?

            def created_at=: (Time) -> Time

            attr_reader customer_reference: String?

            def customer_reference=: (String) -> String

            attr_reader deleted_at: Time?

            def deleted_at=: (Time) -> Time

            attr_reader updated_at: Time?

            def updated_at=: (Time) -> Time

            attr_reader record_type: String?

            def record_type=: (String) -> String

            def initialize: (
              ?id: String,
              ?created_at: Time,
              ?customer_reference: String,
              ?deleted_at: Time,
              ?record_type: String,
              ?updated_at: Time
            ) -> void

            def to_hash: -> {
              id: String,
              created_at: Time,
              customer_reference: String,
              deleted_at: Time,
              record_type: String,
              updated_at: Time
            }
          end

          type payload_status = :created | :completed

          module PayloadStatus
            extend Telnyx::Internal::Type::Enum

            CREATED: :created
            COMPLETED: :completed

            def self?.values: -> ::Array[Telnyx::Models::Porting::EventListResponse::PortingEventDeletedPayload::payload_status]
          end
        end

        type porting_event_messaging_changed_payload =
          {
            id: String,
            available_notification_methods: ::Array[Telnyx::Models::Porting::EventListResponse::PortingEventMessagingChangedPayload::available_notification_method],
            created_at: Time,
            event_type: Telnyx::Models::Porting::EventListResponse::PortingEventMessagingChangedPayload::event_type,
            payload: Telnyx::Models::Porting::EventListResponse::PortingEventMessagingChangedPayload::Payload,
            payload_status: Telnyx::Models::Porting::EventListResponse::PortingEventMessagingChangedPayload::payload_status,
            porting_order_id: String,
            record_type: String,
            updated_at: Time
          }

        class PortingEventMessagingChangedPayload < Telnyx::Internal::Type::BaseModel
          attr_reader id: String?

          def id=: (String) -> String

          attr_reader available_notification_methods: ::Array[Telnyx::Models::Porting::EventListResponse::PortingEventMessagingChangedPayload::available_notification_method]?

          def available_notification_methods=: (
            ::Array[Telnyx::Models::Porting::EventListResponse::PortingEventMessagingChangedPayload::available_notification_method]
          ) -> ::Array[Telnyx::Models::Porting::EventListResponse::PortingEventMessagingChangedPayload::available_notification_method]

          attr_reader created_at: Time?

          def created_at=: (Time) -> Time

          attr_reader event_type: Telnyx::Models::Porting::EventListResponse::PortingEventMessagingChangedPayload::event_type?

          def event_type=: (
            Telnyx::Models::Porting::EventListResponse::PortingEventMessagingChangedPayload::event_type
          ) -> Telnyx::Models::Porting::EventListResponse::PortingEventMessagingChangedPayload::event_type

          attr_reader payload: Telnyx::Models::Porting::EventListResponse::PortingEventMessagingChangedPayload::Payload?

          def payload=: (
            Telnyx::Models::Porting::EventListResponse::PortingEventMessagingChangedPayload::Payload
          ) -> Telnyx::Models::Porting::EventListResponse::PortingEventMessagingChangedPayload::Payload

          attr_reader payload_status: Telnyx::Models::Porting::EventListResponse::PortingEventMessagingChangedPayload::payload_status?

          def payload_status=: (
            Telnyx::Models::Porting::EventListResponse::PortingEventMessagingChangedPayload::payload_status
          ) -> Telnyx::Models::Porting::EventListResponse::PortingEventMessagingChangedPayload::payload_status

          attr_reader porting_order_id: String?

          def porting_order_id=: (String) -> String

          attr_reader updated_at: Time?

          def updated_at=: (Time) -> Time

          attr_reader record_type: String?

          def record_type=: (String) -> String

          def initialize: (
            ?id: String,
            ?available_notification_methods: ::Array[Telnyx::Models::Porting::EventListResponse::PortingEventMessagingChangedPayload::available_notification_method],
            ?created_at: Time,
            ?event_type: Telnyx::Models::Porting::EventListResponse::PortingEventMessagingChangedPayload::event_type,
            ?payload: Telnyx::Models::Porting::EventListResponse::PortingEventMessagingChangedPayload::Payload,
            ?payload_status: Telnyx::Models::Porting::EventListResponse::PortingEventMessagingChangedPayload::payload_status,
            ?porting_order_id: String,
            ?record_type: String,
            ?updated_at: Time
          ) -> void

          def to_hash: -> {
            id: String,
            available_notification_methods: ::Array[Telnyx::Models::Porting::EventListResponse::PortingEventMessagingChangedPayload::available_notification_method],
            created_at: Time,
            event_type: Telnyx::Models::Porting::EventListResponse::PortingEventMessagingChangedPayload::event_type,
            payload: Telnyx::Models::Porting::EventListResponse::PortingEventMessagingChangedPayload::Payload,
            payload_status: Telnyx::Models::Porting::EventListResponse::PortingEventMessagingChangedPayload::payload_status,
            porting_order_id: String,
            record_type: String,
            updated_at: Time
          }

          type available_notification_method = :email | :webhook | :webhook_v1

          module AvailableNotificationMethod
            extend Telnyx::Internal::Type::Enum

            EMAIL: :email
            WEBHOOK: :webhook
            WEBHOOK_V1: :webhook_v1

            def self?.values: -> ::Array[Telnyx::Models::Porting::EventListResponse::PortingEventMessagingChangedPayload::available_notification_method]
          end

          type event_type =
            :"porting_order.deleted"
            | :"porting_order.loa_updated"
            | :"porting_order.messaging_changed"
            | :"porting_order.status_changed"
            | :"porting_order.sharing_token_expired"
            | :"porting_order.new_comment"
            | :"porting_order.split"

          module EventType
            extend Telnyx::Internal::Type::Enum

            PORTING_ORDER_DELETED: :"porting_order.deleted"
            PORTING_ORDER_LOA_UPDATED: :"porting_order.loa_updated"
            PORTING_ORDER_MESSAGING_CHANGED: :"porting_order.messaging_changed"
            PORTING_ORDER_STATUS_CHANGED: :"porting_order.status_changed"
            PORTING_ORDER_SHARING_TOKEN_EXPIRED: :"porting_order.sharing_token_expired"
            PORTING_ORDER_NEW_COMMENT: :"porting_order.new_comment"
            PORTING_ORDER_SPLIT: :"porting_order.split"

            def self?.values: -> ::Array[Telnyx::Models::Porting::EventListResponse::PortingEventMessagingChangedPayload::event_type]
          end

          type payload =
            {
              id: String,
              customer_reference: String,
              messaging: Telnyx::Models::Porting::EventListResponse::PortingEventMessagingChangedPayload::Payload::Messaging,
              support_key: String
            }

          class Payload < Telnyx::Internal::Type::BaseModel
            attr_reader id: String?

            def id=: (String) -> String

            attr_reader customer_reference: String?

            def customer_reference=: (String) -> String

            attr_reader messaging: Telnyx::Models::Porting::EventListResponse::PortingEventMessagingChangedPayload::Payload::Messaging?

            def messaging=: (
              Telnyx::Models::Porting::EventListResponse::PortingEventMessagingChangedPayload::Payload::Messaging
            ) -> Telnyx::Models::Porting::EventListResponse::PortingEventMessagingChangedPayload::Payload::Messaging

            attr_reader support_key: String?

            def support_key=: (String) -> String

            def initialize: (
              ?id: String,
              ?customer_reference: String,
              ?messaging: Telnyx::Models::Porting::EventListResponse::PortingEventMessagingChangedPayload::Payload::Messaging,
              ?support_key: String
            ) -> void

            def to_hash: -> {
              id: String,
              customer_reference: String,
              messaging: Telnyx::Models::Porting::EventListResponse::PortingEventMessagingChangedPayload::Payload::Messaging,
              support_key: String
            }

            type messaging =
              {
                enable_messaging: bool,
                messaging_capable: bool,
                messaging_port_completed: bool,
                messaging_port_status: Telnyx::Models::Porting::EventListResponse::PortingEventMessagingChangedPayload::Payload::Messaging::messaging_port_status
              }

            class Messaging < Telnyx::Internal::Type::BaseModel
              attr_reader enable_messaging: bool?

              def enable_messaging=: (bool) -> bool

              attr_reader messaging_capable: bool?

              def messaging_capable=: (bool) -> bool

              attr_reader messaging_port_completed: bool?

              def messaging_port_completed=: (bool) -> bool

              attr_reader messaging_port_status: Telnyx::Models::Porting::EventListResponse::PortingEventMessagingChangedPayload::Payload::Messaging::messaging_port_status?

              def messaging_port_status=: (
                Telnyx::Models::Porting::EventListResponse::PortingEventMessagingChangedPayload::Payload::Messaging::messaging_port_status
              ) -> Telnyx::Models::Porting::EventListResponse::PortingEventMessagingChangedPayload::Payload::Messaging::messaging_port_status

              def initialize: (
                ?enable_messaging: bool,
                ?messaging_capable: bool,
                ?messaging_port_completed: bool,
                ?messaging_port_status: Telnyx::Models::Porting::EventListResponse::PortingEventMessagingChangedPayload::Payload::Messaging::messaging_port_status
              ) -> void

              def to_hash: -> {
                enable_messaging: bool,
                messaging_capable: bool,
                messaging_port_completed: bool,
                messaging_port_status: Telnyx::Models::Porting::EventListResponse::PortingEventMessagingChangedPayload::Payload::Messaging::messaging_port_status
              }

              type messaging_port_status =
                :not_applicable
                | :pending
                | :activating
                | :exception
                | :canceled
                | :partial_port_complete
                | :ported

              module MessagingPortStatus
                extend Telnyx::Internal::Type::Enum

                NOT_APPLICABLE: :not_applicable
                PENDING: :pending
                ACTIVATING: :activating
                EXCEPTION: :exception
                CANCELED: :canceled
                PARTIAL_PORT_COMPLETE: :partial_port_complete
                PORTED: :ported

                def self?.values: -> ::Array[Telnyx::Models::Porting::EventListResponse::PortingEventMessagingChangedPayload::Payload::Messaging::messaging_port_status]
              end
            end
          end

          type payload_status = :created | :completed

          module PayloadStatus
            extend Telnyx::Internal::Type::Enum

            CREATED: :created
            COMPLETED: :completed

            def self?.values: -> ::Array[Telnyx::Models::Porting::EventListResponse::PortingEventMessagingChangedPayload::payload_status]
          end
        end

        type porting_event_status_changed_event =
          {
            id: String,
            available_notification_methods: ::Array[Telnyx::Models::Porting::EventListResponse::PortingEventStatusChangedEvent::available_notification_method],
            created_at: Time,
            event_type: Telnyx::Models::Porting::EventListResponse::PortingEventStatusChangedEvent::event_type,
            payload: Telnyx::Models::Porting::EventListResponse::PortingEventStatusChangedEvent::Payload,
            payload_status: Telnyx::Models::Porting::EventListResponse::PortingEventStatusChangedEvent::payload_status,
            porting_order_id: String,
            record_type: String,
            updated_at: Time
          }

        class PortingEventStatusChangedEvent < Telnyx::Internal::Type::BaseModel
          attr_reader id: String?

          def id=: (String) -> String

          attr_reader available_notification_methods: ::Array[Telnyx::Models::Porting::EventListResponse::PortingEventStatusChangedEvent::available_notification_method]?

          def available_notification_methods=: (
            ::Array[Telnyx::Models::Porting::EventListResponse::PortingEventStatusChangedEvent::available_notification_method]
          ) -> ::Array[Telnyx::Models::Porting::EventListResponse::PortingEventStatusChangedEvent::available_notification_method]

          attr_reader created_at: Time?

          def created_at=: (Time) -> Time

          attr_reader event_type: Telnyx::Models::Porting::EventListResponse::PortingEventStatusChangedEvent::event_type?

          def event_type=: (
            Telnyx::Models::Porting::EventListResponse::PortingEventStatusChangedEvent::event_type
          ) -> Telnyx::Models::Porting::EventListResponse::PortingEventStatusChangedEvent::event_type

          attr_reader payload: Telnyx::Models::Porting::EventListResponse::PortingEventStatusChangedEvent::Payload?

          def payload=: (
            Telnyx::Models::Porting::EventListResponse::PortingEventStatusChangedEvent::Payload
          ) -> Telnyx::Models::Porting::EventListResponse::PortingEventStatusChangedEvent::Payload

          attr_reader payload_status: Telnyx::Models::Porting::EventListResponse::PortingEventStatusChangedEvent::payload_status?

          def payload_status=: (
            Telnyx::Models::Porting::EventListResponse::PortingEventStatusChangedEvent::payload_status
          ) -> Telnyx::Models::Porting::EventListResponse::PortingEventStatusChangedEvent::payload_status

          attr_reader porting_order_id: String?

          def porting_order_id=: (String) -> String

          attr_reader updated_at: Time?

          def updated_at=: (Time) -> Time

          attr_reader record_type: String?

          def record_type=: (String) -> String

          def initialize: (
            ?id: String,
            ?available_notification_methods: ::Array[Telnyx::Models::Porting::EventListResponse::PortingEventStatusChangedEvent::available_notification_method],
            ?created_at: Time,
            ?event_type: Telnyx::Models::Porting::EventListResponse::PortingEventStatusChangedEvent::event_type,
            ?payload: Telnyx::Models::Porting::EventListResponse::PortingEventStatusChangedEvent::Payload,
            ?payload_status: Telnyx::Models::Porting::EventListResponse::PortingEventStatusChangedEvent::payload_status,
            ?porting_order_id: String,
            ?record_type: String,
            ?updated_at: Time
          ) -> void

          def to_hash: -> {
            id: String,
            available_notification_methods: ::Array[Telnyx::Models::Porting::EventListResponse::PortingEventStatusChangedEvent::available_notification_method],
            created_at: Time,
            event_type: Telnyx::Models::Porting::EventListResponse::PortingEventStatusChangedEvent::event_type,
            payload: Telnyx::Models::Porting::EventListResponse::PortingEventStatusChangedEvent::Payload,
            payload_status: Telnyx::Models::Porting::EventListResponse::PortingEventStatusChangedEvent::payload_status,
            porting_order_id: String,
            record_type: String,
            updated_at: Time
          }

          type available_notification_method = :email | :webhook | :webhook_v1

          module AvailableNotificationMethod
            extend Telnyx::Internal::Type::Enum

            EMAIL: :email
            WEBHOOK: :webhook
            WEBHOOK_V1: :webhook_v1

            def self?.values: -> ::Array[Telnyx::Models::Porting::EventListResponse::PortingEventStatusChangedEvent::available_notification_method]
          end

          type event_type =
            :"porting_order.deleted"
            | :"porting_order.loa_updated"
            | :"porting_order.messaging_changed"
            | :"porting_order.status_changed"
            | :"porting_order.sharing_token_expired"
            | :"porting_order.new_comment"
            | :"porting_order.split"

          module EventType
            extend Telnyx::Internal::Type::Enum

            PORTING_ORDER_DELETED: :"porting_order.deleted"
            PORTING_ORDER_LOA_UPDATED: :"porting_order.loa_updated"
            PORTING_ORDER_MESSAGING_CHANGED: :"porting_order.messaging_changed"
            PORTING_ORDER_STATUS_CHANGED: :"porting_order.status_changed"
            PORTING_ORDER_SHARING_TOKEN_EXPIRED: :"porting_order.sharing_token_expired"
            PORTING_ORDER_NEW_COMMENT: :"porting_order.new_comment"
            PORTING_ORDER_SPLIT: :"porting_order.split"

            def self?.values: -> ::Array[Telnyx::Models::Porting::EventListResponse::PortingEventStatusChangedEvent::event_type]
          end

          type payload =
            {
              id: String,
              customer_reference: String,
              status: Telnyx::PortingOrderStatus,
              support_key: String,
              updated_at: Time,
              webhook_url: String
            }

          class Payload < Telnyx::Internal::Type::BaseModel
            attr_reader id: String?

            def id=: (String) -> String

            attr_reader customer_reference: String?

            def customer_reference=: (String) -> String

            attr_reader status: Telnyx::PortingOrderStatus?

            def status=: (
              Telnyx::PortingOrderStatus
            ) -> Telnyx::PortingOrderStatus

            attr_reader support_key: String?

            def support_key=: (String) -> String

            attr_reader updated_at: Time?

            def updated_at=: (Time) -> Time

            attr_reader webhook_url: String?

            def webhook_url=: (String) -> String

            def initialize: (
              ?id: String,
              ?customer_reference: String,
              ?status: Telnyx::PortingOrderStatus,
              ?support_key: String,
              ?updated_at: Time,
              ?webhook_url: String
            ) -> void

            def to_hash: -> {
              id: String,
              customer_reference: String,
              status: Telnyx::PortingOrderStatus,
              support_key: String,
              updated_at: Time,
              webhook_url: String
            }
          end

          type payload_status = :created | :completed

          module PayloadStatus
            extend Telnyx::Internal::Type::Enum

            CREATED: :created
            COMPLETED: :completed

            def self?.values: -> ::Array[Telnyx::Models::Porting::EventListResponse::PortingEventStatusChangedEvent::payload_status]
          end
        end

        type porting_event_new_comment_event =
          {
            id: String,
            available_notification_methods: ::Array[Telnyx::Models::Porting::EventListResponse::PortingEventNewCommentEvent::available_notification_method],
            created_at: Time,
            event_type: Telnyx::Models::Porting::EventListResponse::PortingEventNewCommentEvent::event_type,
            payload: Telnyx::Models::Porting::EventListResponse::PortingEventNewCommentEvent::Payload,
            payload_status: Telnyx::Models::Porting::EventListResponse::PortingEventNewCommentEvent::payload_status,
            porting_order_id: String,
            record_type: String,
            updated_at: Time
          }

        class PortingEventNewCommentEvent < Telnyx::Internal::Type::BaseModel
          attr_reader id: String?

          def id=: (String) -> String

          attr_reader available_notification_methods: ::Array[Telnyx::Models::Porting::EventListResponse::PortingEventNewCommentEvent::available_notification_method]?

          def available_notification_methods=: (
            ::Array[Telnyx::Models::Porting::EventListResponse::PortingEventNewCommentEvent::available_notification_method]
          ) -> ::Array[Telnyx::Models::Porting::EventListResponse::PortingEventNewCommentEvent::available_notification_method]

          attr_reader created_at: Time?

          def created_at=: (Time) -> Time

          attr_reader event_type: Telnyx::Models::Porting::EventListResponse::PortingEventNewCommentEvent::event_type?

          def event_type=: (
            Telnyx::Models::Porting::EventListResponse::PortingEventNewCommentEvent::event_type
          ) -> Telnyx::Models::Porting::EventListResponse::PortingEventNewCommentEvent::event_type

          attr_reader payload: Telnyx::Models::Porting::EventListResponse::PortingEventNewCommentEvent::Payload?

          def payload=: (
            Telnyx::Models::Porting::EventListResponse::PortingEventNewCommentEvent::Payload
          ) -> Telnyx::Models::Porting::EventListResponse::PortingEventNewCommentEvent::Payload

          attr_reader payload_status: Telnyx::Models::Porting::EventListResponse::PortingEventNewCommentEvent::payload_status?

          def payload_status=: (
            Telnyx::Models::Porting::EventListResponse::PortingEventNewCommentEvent::payload_status
          ) -> Telnyx::Models::Porting::EventListResponse::PortingEventNewCommentEvent::payload_status

          attr_reader porting_order_id: String?

          def porting_order_id=: (String) -> String

          attr_reader updated_at: Time?

          def updated_at=: (Time) -> Time

          attr_reader record_type: String?

          def record_type=: (String) -> String

          def initialize: (
            ?id: String,
            ?available_notification_methods: ::Array[Telnyx::Models::Porting::EventListResponse::PortingEventNewCommentEvent::available_notification_method],
            ?created_at: Time,
            ?event_type: Telnyx::Models::Porting::EventListResponse::PortingEventNewCommentEvent::event_type,
            ?payload: Telnyx::Models::Porting::EventListResponse::PortingEventNewCommentEvent::Payload,
            ?payload_status: Telnyx::Models::Porting::EventListResponse::PortingEventNewCommentEvent::payload_status,
            ?porting_order_id: String,
            ?record_type: String,
            ?updated_at: Time
          ) -> void

          def to_hash: -> {
            id: String,
            available_notification_methods: ::Array[Telnyx::Models::Porting::EventListResponse::PortingEventNewCommentEvent::available_notification_method],
            created_at: Time,
            event_type: Telnyx::Models::Porting::EventListResponse::PortingEventNewCommentEvent::event_type,
            payload: Telnyx::Models::Porting::EventListResponse::PortingEventNewCommentEvent::Payload,
            payload_status: Telnyx::Models::Porting::EventListResponse::PortingEventNewCommentEvent::payload_status,
            porting_order_id: String,
            record_type: String,
            updated_at: Time
          }

          type available_notification_method = :email | :webhook | :webhook_v1

          module AvailableNotificationMethod
            extend Telnyx::Internal::Type::Enum

            EMAIL: :email
            WEBHOOK: :webhook
            WEBHOOK_V1: :webhook_v1

            def self?.values: -> ::Array[Telnyx::Models::Porting::EventListResponse::PortingEventNewCommentEvent::available_notification_method]
          end

          type event_type =
            :"porting_order.deleted"
            | :"porting_order.loa_updated"
            | :"porting_order.messaging_changed"
            | :"porting_order.status_changed"
            | :"porting_order.sharing_token_expired"
            | :"porting_order.new_comment"
            | :"porting_order.split"

          module EventType
            extend Telnyx::Internal::Type::Enum

            PORTING_ORDER_DELETED: :"porting_order.deleted"
            PORTING_ORDER_LOA_UPDATED: :"porting_order.loa_updated"
            PORTING_ORDER_MESSAGING_CHANGED: :"porting_order.messaging_changed"
            PORTING_ORDER_STATUS_CHANGED: :"porting_order.status_changed"
            PORTING_ORDER_SHARING_TOKEN_EXPIRED: :"porting_order.sharing_token_expired"
            PORTING_ORDER_NEW_COMMENT: :"porting_order.new_comment"
            PORTING_ORDER_SPLIT: :"porting_order.split"

            def self?.values: -> ::Array[Telnyx::Models::Porting::EventListResponse::PortingEventNewCommentEvent::event_type]
          end

          type payload =
            {
              comment: Telnyx::Models::Porting::EventListResponse::PortingEventNewCommentEvent::Payload::Comment,
              porting_order_id: String,
              support_key: String
            }

          class Payload < Telnyx::Internal::Type::BaseModel
            attr_reader comment: Telnyx::Models::Porting::EventListResponse::PortingEventNewCommentEvent::Payload::Comment?

            def comment=: (
              Telnyx::Models::Porting::EventListResponse::PortingEventNewCommentEvent::Payload::Comment
            ) -> Telnyx::Models::Porting::EventListResponse::PortingEventNewCommentEvent::Payload::Comment

            attr_reader porting_order_id: String?

            def porting_order_id=: (String) -> String

            attr_reader support_key: String?

            def support_key=: (String) -> String

            def initialize: (
              ?comment: Telnyx::Models::Porting::EventListResponse::PortingEventNewCommentEvent::Payload::Comment,
              ?porting_order_id: String,
              ?support_key: String
            ) -> void

            def to_hash: -> {
              comment: Telnyx::Models::Porting::EventListResponse::PortingEventNewCommentEvent::Payload::Comment,
              porting_order_id: String,
              support_key: String
            }

            type comment =
              {
                id: String,
                body: String,
                inserted_at: Time,
                user_id: String,
                user_type: Telnyx::Models::Porting::EventListResponse::PortingEventNewCommentEvent::Payload::Comment::user_type
              }

            class Comment < Telnyx::Internal::Type::BaseModel
              attr_reader id: String?

              def id=: (String) -> String

              attr_reader body: String?

              def body=: (String) -> String

              attr_reader inserted_at: Time?

              def inserted_at=: (Time) -> Time

              attr_reader user_id: String?

              def user_id=: (String) -> String

              attr_reader user_type: Telnyx::Models::Porting::EventListResponse::PortingEventNewCommentEvent::Payload::Comment::user_type?

              def user_type=: (
                Telnyx::Models::Porting::EventListResponse::PortingEventNewCommentEvent::Payload::Comment::user_type
              ) -> Telnyx::Models::Porting::EventListResponse::PortingEventNewCommentEvent::Payload::Comment::user_type

              def initialize: (
                ?id: String,
                ?body: String,
                ?inserted_at: Time,
                ?user_id: String,
                ?user_type: Telnyx::Models::Porting::EventListResponse::PortingEventNewCommentEvent::Payload::Comment::user_type
              ) -> void

              def to_hash: -> {
                id: String,
                body: String,
                inserted_at: Time,
                user_id: String,
                user_type: Telnyx::Models::Porting::EventListResponse::PortingEventNewCommentEvent::Payload::Comment::user_type
              }

              type user_type = :user | :admin | :system

              module UserType
                extend Telnyx::Internal::Type::Enum

                USER: :user
                ADMIN: :admin
                SYSTEM: :system

                def self?.values: -> ::Array[Telnyx::Models::Porting::EventListResponse::PortingEventNewCommentEvent::Payload::Comment::user_type]
              end
            end
          end

          type payload_status = :created | :completed

          module PayloadStatus
            extend Telnyx::Internal::Type::Enum

            CREATED: :created
            COMPLETED: :completed

            def self?.values: -> ::Array[Telnyx::Models::Porting::EventListResponse::PortingEventNewCommentEvent::payload_status]
          end
        end

        type porting_event_split_event =
          {
            id: String,
            available_notification_methods: ::Array[Telnyx::Models::Porting::EventListResponse::PortingEventSplitEvent::available_notification_method],
            created_at: Time,
            event_type: Telnyx::Models::Porting::EventListResponse::PortingEventSplitEvent::event_type,
            payload: Telnyx::Models::Porting::EventListResponse::PortingEventSplitEvent::Payload,
            payload_status: Telnyx::Models::Porting::EventListResponse::PortingEventSplitEvent::payload_status,
            porting_order_id: String,
            record_type: String,
            updated_at: Time
          }

        class PortingEventSplitEvent < Telnyx::Internal::Type::BaseModel
          attr_reader id: String?

          def id=: (String) -> String

          attr_reader available_notification_methods: ::Array[Telnyx::Models::Porting::EventListResponse::PortingEventSplitEvent::available_notification_method]?

          def available_notification_methods=: (
            ::Array[Telnyx::Models::Porting::EventListResponse::PortingEventSplitEvent::available_notification_method]
          ) -> ::Array[Telnyx::Models::Porting::EventListResponse::PortingEventSplitEvent::available_notification_method]

          attr_reader created_at: Time?

          def created_at=: (Time) -> Time

          attr_reader event_type: Telnyx::Models::Porting::EventListResponse::PortingEventSplitEvent::event_type?

          def event_type=: (
            Telnyx::Models::Porting::EventListResponse::PortingEventSplitEvent::event_type
          ) -> Telnyx::Models::Porting::EventListResponse::PortingEventSplitEvent::event_type

          attr_reader payload: Telnyx::Models::Porting::EventListResponse::PortingEventSplitEvent::Payload?

          def payload=: (
            Telnyx::Models::Porting::EventListResponse::PortingEventSplitEvent::Payload
          ) -> Telnyx::Models::Porting::EventListResponse::PortingEventSplitEvent::Payload

          attr_reader payload_status: Telnyx::Models::Porting::EventListResponse::PortingEventSplitEvent::payload_status?

          def payload_status=: (
            Telnyx::Models::Porting::EventListResponse::PortingEventSplitEvent::payload_status
          ) -> Telnyx::Models::Porting::EventListResponse::PortingEventSplitEvent::payload_status

          attr_reader porting_order_id: String?

          def porting_order_id=: (String) -> String

          attr_reader updated_at: Time?

          def updated_at=: (Time) -> Time

          attr_reader record_type: String?

          def record_type=: (String) -> String

          def initialize: (
            ?id: String,
            ?available_notification_methods: ::Array[Telnyx::Models::Porting::EventListResponse::PortingEventSplitEvent::available_notification_method],
            ?created_at: Time,
            ?event_type: Telnyx::Models::Porting::EventListResponse::PortingEventSplitEvent::event_type,
            ?payload: Telnyx::Models::Porting::EventListResponse::PortingEventSplitEvent::Payload,
            ?payload_status: Telnyx::Models::Porting::EventListResponse::PortingEventSplitEvent::payload_status,
            ?porting_order_id: String,
            ?record_type: String,
            ?updated_at: Time
          ) -> void

          def to_hash: -> {
            id: String,
            available_notification_methods: ::Array[Telnyx::Models::Porting::EventListResponse::PortingEventSplitEvent::available_notification_method],
            created_at: Time,
            event_type: Telnyx::Models::Porting::EventListResponse::PortingEventSplitEvent::event_type,
            payload: Telnyx::Models::Porting::EventListResponse::PortingEventSplitEvent::Payload,
            payload_status: Telnyx::Models::Porting::EventListResponse::PortingEventSplitEvent::payload_status,
            porting_order_id: String,
            record_type: String,
            updated_at: Time
          }

          type available_notification_method = :email | :webhook | :webhook_v1

          module AvailableNotificationMethod
            extend Telnyx::Internal::Type::Enum

            EMAIL: :email
            WEBHOOK: :webhook
            WEBHOOK_V1: :webhook_v1

            def self?.values: -> ::Array[Telnyx::Models::Porting::EventListResponse::PortingEventSplitEvent::available_notification_method]
          end

          type event_type =
            :"porting_order.deleted"
            | :"porting_order.loa_updated"
            | :"porting_order.messaging_changed"
            | :"porting_order.status_changed"
            | :"porting_order.sharing_token_expired"
            | :"porting_order.new_comment"
            | :"porting_order.split"

          module EventType
            extend Telnyx::Internal::Type::Enum

            PORTING_ORDER_DELETED: :"porting_order.deleted"
            PORTING_ORDER_LOA_UPDATED: :"porting_order.loa_updated"
            PORTING_ORDER_MESSAGING_CHANGED: :"porting_order.messaging_changed"
            PORTING_ORDER_STATUS_CHANGED: :"porting_order.status_changed"
            PORTING_ORDER_SHARING_TOKEN_EXPIRED: :"porting_order.sharing_token_expired"
            PORTING_ORDER_NEW_COMMENT: :"porting_order.new_comment"
            PORTING_ORDER_SPLIT: :"porting_order.split"

            def self?.values: -> ::Array[Telnyx::Models::Porting::EventListResponse::PortingEventSplitEvent::event_type]
          end

          type payload =
            {
              from: Telnyx::Models::Porting::EventListResponse::PortingEventSplitEvent::Payload::From,
              porting_phone_numbers: ::Array[Telnyx::Models::Porting::EventListResponse::PortingEventSplitEvent::Payload::PortingPhoneNumber],
              to: Telnyx::Models::Porting::EventListResponse::PortingEventSplitEvent::Payload::To
            }

          class Payload < Telnyx::Internal::Type::BaseModel
            attr_reader from: Telnyx::Models::Porting::EventListResponse::PortingEventSplitEvent::Payload::From?

            def from=: (
              Telnyx::Models::Porting::EventListResponse::PortingEventSplitEvent::Payload::From
            ) -> Telnyx::Models::Porting::EventListResponse::PortingEventSplitEvent::Payload::From

            attr_reader porting_phone_numbers: ::Array[Telnyx::Models::Porting::EventListResponse::PortingEventSplitEvent::Payload::PortingPhoneNumber]?

            def porting_phone_numbers=: (
              ::Array[Telnyx::Models::Porting::EventListResponse::PortingEventSplitEvent::Payload::PortingPhoneNumber]
            ) -> ::Array[Telnyx::Models::Porting::EventListResponse::PortingEventSplitEvent::Payload::PortingPhoneNumber]

            attr_reader to: Telnyx::Models::Porting::EventListResponse::PortingEventSplitEvent::Payload::To?

            def to=: (
              Telnyx::Models::Porting::EventListResponse::PortingEventSplitEvent::Payload::To
            ) -> Telnyx::Models::Porting::EventListResponse::PortingEventSplitEvent::Payload::To

            def initialize: (
              ?from: Telnyx::Models::Porting::EventListResponse::PortingEventSplitEvent::Payload::From,
              ?porting_phone_numbers: ::Array[Telnyx::Models::Porting::EventListResponse::PortingEventSplitEvent::Payload::PortingPhoneNumber],
              ?to: Telnyx::Models::Porting::EventListResponse::PortingEventSplitEvent::Payload::To
            ) -> void

            def to_hash: -> {
              from: Telnyx::Models::Porting::EventListResponse::PortingEventSplitEvent::Payload::From,
              porting_phone_numbers: ::Array[Telnyx::Models::Porting::EventListResponse::PortingEventSplitEvent::Payload::PortingPhoneNumber],
              to: Telnyx::Models::Porting::EventListResponse::PortingEventSplitEvent::Payload::To
            }

            type from = { id: String }

            class From < Telnyx::Internal::Type::BaseModel
              attr_reader id: String?

              def id=: (String) -> String

              def initialize: (?id: String) -> void

              def to_hash: -> { id: String }
            end

            type porting_phone_number = { id: String }

            class PortingPhoneNumber < Telnyx::Internal::Type::BaseModel
              attr_reader id: String?

              def id=: (String) -> String

              def initialize: (?id: String) -> void

              def to_hash: -> { id: String }
            end

            type to = { id: String }

            class To < Telnyx::Internal::Type::BaseModel
              attr_reader id: String?

              def id=: (String) -> String

              def initialize: (?id: String) -> void

              def to_hash: -> { id: String }
            end
          end

          type payload_status = :created | :completed

          module PayloadStatus
            extend Telnyx::Internal::Type::Enum

            CREATED: :created
            COMPLETED: :completed

            def self?.values: -> ::Array[Telnyx::Models::Porting::EventListResponse::PortingEventSplitEvent::payload_status]
          end
        end

        type porting_event_without_webhook =
          {
            id: String,
            available_notification_methods: ::Array[Telnyx::Models::Porting::EventListResponse::PortingEventWithoutWebhook::available_notification_method],
            created_at: Time,
            event_type: Telnyx::Models::Porting::EventListResponse::PortingEventWithoutWebhook::event_type,
            payload: nil,
            payload_status: Telnyx::Models::Porting::EventListResponse::PortingEventWithoutWebhook::payload_status,
            porting_order_id: String,
            record_type: String,
            updated_at: Time
          }

        class PortingEventWithoutWebhook < Telnyx::Internal::Type::BaseModel
          attr_reader id: String?

          def id=: (String) -> String

          attr_reader available_notification_methods: ::Array[Telnyx::Models::Porting::EventListResponse::PortingEventWithoutWebhook::available_notification_method]?

          def available_notification_methods=: (
            ::Array[Telnyx::Models::Porting::EventListResponse::PortingEventWithoutWebhook::available_notification_method]
          ) -> ::Array[Telnyx::Models::Porting::EventListResponse::PortingEventWithoutWebhook::available_notification_method]

          attr_reader created_at: Time?

          def created_at=: (Time) -> Time

          attr_reader event_type: Telnyx::Models::Porting::EventListResponse::PortingEventWithoutWebhook::event_type?

          def event_type=: (
            Telnyx::Models::Porting::EventListResponse::PortingEventWithoutWebhook::event_type
          ) -> Telnyx::Models::Porting::EventListResponse::PortingEventWithoutWebhook::event_type

          attr_accessor payload: nil

          attr_reader payload_status: Telnyx::Models::Porting::EventListResponse::PortingEventWithoutWebhook::payload_status?

          def payload_status=: (
            Telnyx::Models::Porting::EventListResponse::PortingEventWithoutWebhook::payload_status
          ) -> Telnyx::Models::Porting::EventListResponse::PortingEventWithoutWebhook::payload_status

          attr_reader porting_order_id: String?

          def porting_order_id=: (String) -> String

          attr_reader updated_at: Time?

          def updated_at=: (Time) -> Time

          attr_reader record_type: String?

          def record_type=: (String) -> String

          def initialize: (
            ?id: String,
            ?available_notification_methods: ::Array[Telnyx::Models::Porting::EventListResponse::PortingEventWithoutWebhook::available_notification_method],
            ?created_at: Time,
            ?event_type: Telnyx::Models::Porting::EventListResponse::PortingEventWithoutWebhook::event_type,
            ?payload: nil,
            ?payload_status: Telnyx::Models::Porting::EventListResponse::PortingEventWithoutWebhook::payload_status,
            ?porting_order_id: String,
            ?record_type: String,
            ?updated_at: Time
          ) -> void

          def to_hash: -> {
            id: String,
            available_notification_methods: ::Array[Telnyx::Models::Porting::EventListResponse::PortingEventWithoutWebhook::available_notification_method],
            created_at: Time,
            event_type: Telnyx::Models::Porting::EventListResponse::PortingEventWithoutWebhook::event_type,
            payload: nil,
            payload_status: Telnyx::Models::Porting::EventListResponse::PortingEventWithoutWebhook::payload_status,
            porting_order_id: String,
            record_type: String,
            updated_at: Time
          }

          type available_notification_method = :email | :webhook | :webhook_v1

          module AvailableNotificationMethod
            extend Telnyx::Internal::Type::Enum

            EMAIL: :email
            WEBHOOK: :webhook
            WEBHOOK_V1: :webhook_v1

            def self?.values: -> ::Array[Telnyx::Models::Porting::EventListResponse::PortingEventWithoutWebhook::available_notification_method]
          end

          type event_type =
            :"porting_order.deleted"
            | :"porting_order.loa_updated"
            | :"porting_order.messaging_changed"
            | :"porting_order.status_changed"
            | :"porting_order.sharing_token_expired"
            | :"porting_order.new_comment"
            | :"porting_order.split"

          module EventType
            extend Telnyx::Internal::Type::Enum

            PORTING_ORDER_DELETED: :"porting_order.deleted"
            PORTING_ORDER_LOA_UPDATED: :"porting_order.loa_updated"
            PORTING_ORDER_MESSAGING_CHANGED: :"porting_order.messaging_changed"
            PORTING_ORDER_STATUS_CHANGED: :"porting_order.status_changed"
            PORTING_ORDER_SHARING_TOKEN_EXPIRED: :"porting_order.sharing_token_expired"
            PORTING_ORDER_NEW_COMMENT: :"porting_order.new_comment"
            PORTING_ORDER_SPLIT: :"porting_order.split"

            def self?.values: -> ::Array[Telnyx::Models::Porting::EventListResponse::PortingEventWithoutWebhook::event_type]
          end

          type payload_status = :created | :completed

          module PayloadStatus
            extend Telnyx::Internal::Type::Enum

            CREATED: :created
            COMPLETED: :completed

            def self?.values: -> ::Array[Telnyx::Models::Porting::EventListResponse::PortingEventWithoutWebhook::payload_status]
          end
        end

        def self?.variants: -> ::Array[Telnyx::Models::Porting::event_list_response]
      end
    end
  end
end
