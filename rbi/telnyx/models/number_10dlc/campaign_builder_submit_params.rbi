# typed: strong

module Telnyx
  module Models
    module Number10dlc
      class CampaignBuilderSubmitParams < Telnyx::Internal::Type::BaseModel
        extend Telnyx::Internal::Type::RequestParameters::Converter
        include Telnyx::Internal::Type::RequestParameters

        OrHash =
          T.type_alias do
            T.any(
              Telnyx::Number10dlc::CampaignBuilderSubmitParams,
              Telnyx::Internal::AnyHash
            )
          end

        # Alphanumeric identifier of the brand associated with this campaign.
        sig { returns(String) }
        attr_accessor :brand_id

        # Summary description of this campaign.
        sig { returns(String) }
        attr_accessor :description

        # Campaign usecase. Must be of defined valid types. Use `/registry/enum/usecase`
        # operation to retrieve usecases available for given brand.
        sig { returns(String) }
        attr_accessor :usecase

        # Age gated message content in campaign.
        sig { returns(T.nilable(T::Boolean)) }
        attr_reader :age_gated

        sig { params(age_gated: T::Boolean).void }
        attr_writer :age_gated

        # Campaign subscription auto-renewal option. If set to true, then campaign will
        # automatically renewal at end of billing cycle.
        sig { returns(T.nilable(T::Boolean)) }
        attr_reader :auto_renewal

        sig { params(auto_renewal: T::Boolean).void }
        attr_writer :auto_renewal

        # Direct lending or loan arrangement
        sig { returns(T.nilable(T::Boolean)) }
        attr_reader :direct_lending

        sig { params(direct_lending: T::Boolean).void }
        attr_writer :direct_lending

        # Does message generated by the campaign include URL link in SMS?
        sig { returns(T.nilable(T::Boolean)) }
        attr_reader :embedded_link

        sig { params(embedded_link: T::Boolean).void }
        attr_writer :embedded_link

        # Sample of an embedded link that will be sent to subscribers.
        sig { returns(T.nilable(String)) }
        attr_reader :embedded_link_sample

        sig { params(embedded_link_sample: String).void }
        attr_writer :embedded_link_sample

        # Does message generated by the campaign include phone number in SMS?
        sig { returns(T.nilable(T::Boolean)) }
        attr_reader :embedded_phone

        sig { params(embedded_phone: T::Boolean).void }
        attr_writer :embedded_phone

        # Subscriber help keywords. Multiple keywords are comma separated without space.
        sig { returns(T.nilable(String)) }
        attr_reader :help_keywords

        sig { params(help_keywords: String).void }
        attr_writer :help_keywords

        # Help message of the campaign.
        sig { returns(T.nilable(String)) }
        attr_reader :help_message

        sig { params(help_message: String).void }
        attr_writer :help_message

        # Message flow description.
        sig { returns(T.nilable(String)) }
        attr_reader :message_flow

        sig { params(message_flow: String).void }
        attr_writer :message_flow

        # Submit campaign to given list of MNOs by MNO's network ID. Default is all MNOs
        # if no value provided.
        sig { returns(T.nilable(T::Array[Integer])) }
        attr_reader :mno_ids

        sig { params(mno_ids: T::Array[Integer]).void }
        attr_writer :mno_ids

        # Does campaign utilize pool of phone numbers?
        sig { returns(T.nilable(T::Boolean)) }
        attr_reader :number_pool

        sig { params(number_pool: T::Boolean).void }
        attr_writer :number_pool

        # Subscriber opt-in keywords. Multiple keywords are comma separated without space.
        sig { returns(T.nilable(String)) }
        attr_reader :optin_keywords

        sig { params(optin_keywords: String).void }
        attr_writer :optin_keywords

        # Subscriber opt-in message.
        sig { returns(T.nilable(String)) }
        attr_reader :optin_message

        sig { params(optin_message: String).void }
        attr_writer :optin_message

        # Subscriber opt-out keywords. Multiple keywords are comma separated without
        # space.
        sig { returns(T.nilable(String)) }
        attr_reader :optout_keywords

        sig { params(optout_keywords: String).void }
        attr_writer :optout_keywords

        # Subscriber opt-out message.
        sig { returns(T.nilable(String)) }
        attr_reader :optout_message

        sig { params(optout_message: String).void }
        attr_writer :optout_message

        # Link to the campaign's privacy policy.
        sig { returns(T.nilable(String)) }
        attr_reader :privacy_policy_link

        sig { params(privacy_policy_link: String).void }
        attr_writer :privacy_policy_link

        # Caller supplied campaign reference ID. If supplied, the value must be unique
        # across all submitted campaigns. Can be used to prevent duplicate campaign
        # registrations.
        sig { returns(T.nilable(String)) }
        attr_reader :reference_id

        sig { params(reference_id: String).void }
        attr_writer :reference_id

        # Alphanumeric identifier of the reseller that you want to associate with this
        # campaign.
        sig { returns(T.nilable(String)) }
        attr_reader :reseller_id

        sig { params(reseller_id: String).void }
        attr_writer :reseller_id

        # Message sample. Some campaign tiers require 1 or more message samples.
        sig { returns(T.nilable(String)) }
        attr_reader :sample1

        sig { params(sample1: String).void }
        attr_writer :sample1

        # Message sample. Some campaign tiers require 2 or more message samples.
        sig { returns(T.nilable(String)) }
        attr_reader :sample2

        sig { params(sample2: String).void }
        attr_writer :sample2

        # Message sample. Some campaign tiers require 3 or more message samples.
        sig { returns(T.nilable(String)) }
        attr_reader :sample3

        sig { params(sample3: String).void }
        attr_writer :sample3

        # Message sample. Some campaign tiers require 4 or more message samples.
        sig { returns(T.nilable(String)) }
        attr_reader :sample4

        sig { params(sample4: String).void }
        attr_writer :sample4

        # Message sample. Some campaign tiers require 5 or more message samples.
        sig { returns(T.nilable(String)) }
        attr_reader :sample5

        sig { params(sample5: String).void }
        attr_writer :sample5

        # Does campaign responds to help keyword(s)?
        sig { returns(T.nilable(T::Boolean)) }
        attr_reader :subscriber_help

        sig { params(subscriber_help: T::Boolean).void }
        attr_writer :subscriber_help

        # Does campaign require subscriber to opt-in before SMS is sent to subscriber?
        sig { returns(T.nilable(T::Boolean)) }
        attr_reader :subscriber_optin

        sig { params(subscriber_optin: T::Boolean).void }
        attr_writer :subscriber_optin

        # Does campaign support subscriber opt-out keyword(s)?
        sig { returns(T.nilable(T::Boolean)) }
        attr_reader :subscriber_optout

        sig { params(subscriber_optout: T::Boolean).void }
        attr_writer :subscriber_optout

        # Campaign sub-usecases. Must be of defined valid sub-usecase types. Use
        # `/registry/enum/usecase` operation to retrieve list of valid sub-usecases
        sig { returns(T.nilable(T::Array[String])) }
        attr_reader :sub_usecases

        sig { params(sub_usecases: T::Array[String]).void }
        attr_writer :sub_usecases

        # Tags to be set on the Campaign.
        sig { returns(T.nilable(T::Array[String])) }
        attr_reader :tag

        sig { params(tag: T::Array[String]).void }
        attr_writer :tag

        # Is terms and conditions accepted?
        sig { returns(T.nilable(T::Boolean)) }
        attr_reader :terms_and_conditions

        sig { params(terms_and_conditions: T::Boolean).void }
        attr_writer :terms_and_conditions

        # Link to the campaign's terms and conditions.
        sig { returns(T.nilable(String)) }
        attr_reader :terms_and_conditions_link

        sig { params(terms_and_conditions_link: String).void }
        attr_writer :terms_and_conditions_link

        # Failover webhook to which campaign status updates are sent.
        sig { returns(T.nilable(String)) }
        attr_reader :webhook_failover_url

        sig { params(webhook_failover_url: String).void }
        attr_writer :webhook_failover_url

        # Webhook to which campaign status updates are sent.
        sig { returns(T.nilable(String)) }
        attr_reader :webhook_url

        sig { params(webhook_url: String).void }
        attr_writer :webhook_url

        sig do
          params(
            brand_id: String,
            description: String,
            usecase: String,
            age_gated: T::Boolean,
            auto_renewal: T::Boolean,
            direct_lending: T::Boolean,
            embedded_link: T::Boolean,
            embedded_link_sample: String,
            embedded_phone: T::Boolean,
            help_keywords: String,
            help_message: String,
            message_flow: String,
            mno_ids: T::Array[Integer],
            number_pool: T::Boolean,
            optin_keywords: String,
            optin_message: String,
            optout_keywords: String,
            optout_message: String,
            privacy_policy_link: String,
            reference_id: String,
            reseller_id: String,
            sample1: String,
            sample2: String,
            sample3: String,
            sample4: String,
            sample5: String,
            subscriber_help: T::Boolean,
            subscriber_optin: T::Boolean,
            subscriber_optout: T::Boolean,
            sub_usecases: T::Array[String],
            tag: T::Array[String],
            terms_and_conditions: T::Boolean,
            terms_and_conditions_link: String,
            webhook_failover_url: String,
            webhook_url: String,
            request_options: Telnyx::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def self.new(
          # Alphanumeric identifier of the brand associated with this campaign.
          brand_id:,
          # Summary description of this campaign.
          description:,
          # Campaign usecase. Must be of defined valid types. Use `/registry/enum/usecase`
          # operation to retrieve usecases available for given brand.
          usecase:,
          # Age gated message content in campaign.
          age_gated: nil,
          # Campaign subscription auto-renewal option. If set to true, then campaign will
          # automatically renewal at end of billing cycle.
          auto_renewal: nil,
          # Direct lending or loan arrangement
          direct_lending: nil,
          # Does message generated by the campaign include URL link in SMS?
          embedded_link: nil,
          # Sample of an embedded link that will be sent to subscribers.
          embedded_link_sample: nil,
          # Does message generated by the campaign include phone number in SMS?
          embedded_phone: nil,
          # Subscriber help keywords. Multiple keywords are comma separated without space.
          help_keywords: nil,
          # Help message of the campaign.
          help_message: nil,
          # Message flow description.
          message_flow: nil,
          # Submit campaign to given list of MNOs by MNO's network ID. Default is all MNOs
          # if no value provided.
          mno_ids: nil,
          # Does campaign utilize pool of phone numbers?
          number_pool: nil,
          # Subscriber opt-in keywords. Multiple keywords are comma separated without space.
          optin_keywords: nil,
          # Subscriber opt-in message.
          optin_message: nil,
          # Subscriber opt-out keywords. Multiple keywords are comma separated without
          # space.
          optout_keywords: nil,
          # Subscriber opt-out message.
          optout_message: nil,
          # Link to the campaign's privacy policy.
          privacy_policy_link: nil,
          # Caller supplied campaign reference ID. If supplied, the value must be unique
          # across all submitted campaigns. Can be used to prevent duplicate campaign
          # registrations.
          reference_id: nil,
          # Alphanumeric identifier of the reseller that you want to associate with this
          # campaign.
          reseller_id: nil,
          # Message sample. Some campaign tiers require 1 or more message samples.
          sample1: nil,
          # Message sample. Some campaign tiers require 2 or more message samples.
          sample2: nil,
          # Message sample. Some campaign tiers require 3 or more message samples.
          sample3: nil,
          # Message sample. Some campaign tiers require 4 or more message samples.
          sample4: nil,
          # Message sample. Some campaign tiers require 5 or more message samples.
          sample5: nil,
          # Does campaign responds to help keyword(s)?
          subscriber_help: nil,
          # Does campaign require subscriber to opt-in before SMS is sent to subscriber?
          subscriber_optin: nil,
          # Does campaign support subscriber opt-out keyword(s)?
          subscriber_optout: nil,
          # Campaign sub-usecases. Must be of defined valid sub-usecase types. Use
          # `/registry/enum/usecase` operation to retrieve list of valid sub-usecases
          sub_usecases: nil,
          # Tags to be set on the Campaign.
          tag: nil,
          # Is terms and conditions accepted?
          terms_and_conditions: nil,
          # Link to the campaign's terms and conditions.
          terms_and_conditions_link: nil,
          # Failover webhook to which campaign status updates are sent.
          webhook_failover_url: nil,
          # Webhook to which campaign status updates are sent.
          webhook_url: nil,
          request_options: {}
        )
        end

        sig do
          override.returns(
            {
              brand_id: String,
              description: String,
              usecase: String,
              age_gated: T::Boolean,
              auto_renewal: T::Boolean,
              direct_lending: T::Boolean,
              embedded_link: T::Boolean,
              embedded_link_sample: String,
              embedded_phone: T::Boolean,
              help_keywords: String,
              help_message: String,
              message_flow: String,
              mno_ids: T::Array[Integer],
              number_pool: T::Boolean,
              optin_keywords: String,
              optin_message: String,
              optout_keywords: String,
              optout_message: String,
              privacy_policy_link: String,
              reference_id: String,
              reseller_id: String,
              sample1: String,
              sample2: String,
              sample3: String,
              sample4: String,
              sample5: String,
              subscriber_help: T::Boolean,
              subscriber_optin: T::Boolean,
              subscriber_optout: T::Boolean,
              sub_usecases: T::Array[String],
              tag: T::Array[String],
              terms_and_conditions: T::Boolean,
              terms_and_conditions_link: String,
              webhook_failover_url: String,
              webhook_url: String,
              request_options: Telnyx::RequestOptions
            }
          )
        end
        def to_hash
        end
      end
    end
  end
end
