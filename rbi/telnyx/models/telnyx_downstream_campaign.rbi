# typed: strong

module Telnyx
  module Models
    class TelnyxDownstreamCampaign < Telnyx::Internal::Type::BaseModel
      OrHash =
        T.type_alias do
          T.any(Telnyx::TelnyxDownstreamCampaign, Telnyx::Internal::AnyHash)
        end

      # Unique identifier assigned to the brand by the registry.
      sig { returns(String) }
      attr_accessor :tcr_brand_id

      # Unique identifier assigned to the campaign by the registry.
      sig { returns(String) }
      attr_accessor :tcr_campaign_id

      # Age gated content in campaign.
      sig { returns(T.nilable(T::Boolean)) }
      attr_reader :age_gated

      sig { params(age_gated: T::Boolean).void }
      attr_writer :age_gated

      # Number of phone numbers associated with the campaign
      sig { returns(T.nilable(Float)) }
      attr_reader :assigned_phone_numbers_count

      sig { params(assigned_phone_numbers_count: Float).void }
      attr_writer :assigned_phone_numbers_count

      # Display or marketing name of the brand.
      sig { returns(T.nilable(String)) }
      attr_reader :brand_display_name

      sig { params(brand_display_name: String).void }
      attr_writer :brand_display_name

      # Campaign status
      sig do
        returns(
          T.nilable(
            Telnyx::TelnyxDownstreamCampaign::CampaignStatus::TaggedSymbol
          )
        )
      end
      attr_reader :campaign_status

      sig do
        params(
          campaign_status:
            Telnyx::TelnyxDownstreamCampaign::CampaignStatus::OrSymbol
        ).void
      end
      attr_writer :campaign_status

      # Date and time that the brand was created at.
      sig { returns(T.nilable(String)) }
      attr_reader :created_at

      sig { params(created_at: String).void }
      attr_writer :created_at

      # Summary description of this campaign.
      sig { returns(T.nilable(String)) }
      attr_reader :description

      sig { params(description: String).void }
      attr_writer :description

      # Direct lending or loan arrangement.
      sig { returns(T.nilable(T::Boolean)) }
      attr_reader :direct_lending

      sig { params(direct_lending: T::Boolean).void }
      attr_writer :direct_lending

      # Does message generated by the campaign include URL link in SMS?
      sig { returns(T.nilable(T::Boolean)) }
      attr_reader :embedded_link

      sig { params(embedded_link: T::Boolean).void }
      attr_writer :embedded_link

      # Sample of an embedded link that will be sent to subscribers.
      sig { returns(T.nilable(String)) }
      attr_reader :embedded_link_sample

      sig { params(embedded_link_sample: String).void }
      attr_writer :embedded_link_sample

      # Does message generated by the campaign include phone number in SMS?
      sig { returns(T.nilable(T::Boolean)) }
      attr_reader :embedded_phone

      sig { params(embedded_phone: T::Boolean).void }
      attr_writer :embedded_phone

      # Failure reasons if campaign submission failed
      sig { returns(T.nilable(String)) }
      attr_reader :failure_reasons

      sig { params(failure_reasons: String).void }
      attr_writer :failure_reasons

      # Subscriber help keywords. Multiple keywords are comma separated without space.
      sig { returns(T.nilable(String)) }
      attr_reader :help_keywords

      sig { params(help_keywords: String).void }
      attr_writer :help_keywords

      # Help message of the campaign.
      sig { returns(T.nilable(String)) }
      attr_reader :help_message

      sig { params(help_message: String).void }
      attr_writer :help_message

      # Indicates whether the campaign has a T-Mobile number pool ID associated with it.
      sig { returns(T.nilable(T::Boolean)) }
      attr_reader :is_number_pooling_enabled

      sig { params(is_number_pooling_enabled: T::Boolean).void }
      attr_writer :is_number_pooling_enabled

      # Message flow description.
      sig { returns(T.nilable(String)) }
      attr_reader :message_flow

      sig { params(message_flow: String).void }
      attr_writer :message_flow

      # Does campaign utilize pool of phone numbers?
      sig { returns(T.nilable(T::Boolean)) }
      attr_reader :number_pool

      sig { params(number_pool: T::Boolean).void }
      attr_writer :number_pool

      # Subscriber opt-in keywords. Multiple keywords are comma separated without space.
      sig { returns(T.nilable(String)) }
      attr_reader :optin_keywords

      sig { params(optin_keywords: String).void }
      attr_writer :optin_keywords

      # Subscriber opt-in message.
      sig { returns(T.nilable(String)) }
      attr_reader :optin_message

      sig { params(optin_message: String).void }
      attr_writer :optin_message

      # Subscriber opt-out keywords. Multiple keywords are comma separated without
      # space.
      sig { returns(T.nilable(String)) }
      attr_reader :optout_keywords

      sig { params(optout_keywords: String).void }
      attr_writer :optout_keywords

      # Subscriber opt-out message.
      sig { returns(T.nilable(String)) }
      attr_reader :optout_message

      sig { params(optout_message: String).void }
      attr_writer :optout_message

      # Link to the campaign's privacy policy.
      sig { returns(T.nilable(String)) }
      attr_reader :privacy_policy_link

      sig { params(privacy_policy_link: String).void }
      attr_writer :privacy_policy_link

      # Message sample. Some campaign tiers require 1 or more message samples.
      sig { returns(T.nilable(String)) }
      attr_reader :sample1

      sig { params(sample1: String).void }
      attr_writer :sample1

      # Message sample. Some campaign tiers require 2 or more message samples.
      sig { returns(T.nilable(String)) }
      attr_reader :sample2

      sig { params(sample2: String).void }
      attr_writer :sample2

      # Message sample. Some campaign tiers require 3 or more message samples.
      sig { returns(T.nilable(String)) }
      attr_reader :sample3

      sig { params(sample3: String).void }
      attr_writer :sample3

      # Message sample. Some campaign tiers require 4 or more message samples.
      sig { returns(T.nilable(String)) }
      attr_reader :sample4

      sig { params(sample4: String).void }
      attr_writer :sample4

      # Message sample. Some campaign tiers require 5 or more message samples.
      sig { returns(T.nilable(String)) }
      attr_reader :sample5

      sig { params(sample5: String).void }
      attr_writer :sample5

      # Does campaign require subscriber to opt-in before SMS is sent to subscriber?
      sig { returns(T.nilable(T::Boolean)) }
      attr_reader :subscriber_optin

      sig { params(subscriber_optin: T::Boolean).void }
      attr_writer :subscriber_optin

      # Does campaign support subscriber opt-out keyword(s)?
      sig { returns(T.nilable(T::Boolean)) }
      attr_reader :subscriber_optout

      sig { params(subscriber_optout: T::Boolean).void }
      attr_writer :subscriber_optout

      # Campaign sub-usecases. Must be of defined valid sub-usecase types. Use
      # `/registry/enum/usecase` operation to retrieve list of valid sub-usecases
      sig { returns(T.nilable(T::Array[String])) }
      attr_reader :sub_usecases

      sig { params(sub_usecases: T::Array[String]).void }
      attr_writer :sub_usecases

      # Is terms & conditions accepted?
      sig { returns(T.nilable(T::Boolean)) }
      attr_reader :terms_and_conditions

      sig { params(terms_and_conditions: T::Boolean).void }
      attr_writer :terms_and_conditions

      # Link to the campaign's terms and conditions.
      sig { returns(T.nilable(String)) }
      attr_reader :terms_and_conditions_link

      sig { params(terms_and_conditions_link: String).void }
      attr_writer :terms_and_conditions_link

      # Date and time that the brand was last updated at.
      sig { returns(T.nilable(String)) }
      attr_reader :updated_at

      sig { params(updated_at: String).void }
      attr_writer :updated_at

      # Campaign usecase. Must be of defined valid types. Use `/registry/enum/usecase`
      # operation to retrieve usecases available for given brand.
      sig { returns(T.nilable(String)) }
      attr_reader :usecase

      sig { params(usecase: String).void }
      attr_writer :usecase

      # Failover webhook to which campaign status updates are sent.
      sig { returns(T.nilable(String)) }
      attr_reader :webhook_failover_url

      sig { params(webhook_failover_url: String).void }
      attr_writer :webhook_failover_url

      # Webhook to which campaign status updates are sent.
      sig { returns(T.nilable(String)) }
      attr_reader :webhook_url

      sig { params(webhook_url: String).void }
      attr_writer :webhook_url

      # Campaign is generated by the 10DLC registry once the corresponding campaign
      # request is approved. Each campaign is assigned a unique identifier -
      # **campaignId**. Once a campaign is activated, limited information is published
      # to the NetNumber OSR service for consumption by members of the ecosystem. When a
      # campaign is suspended(reversible) or expired(non-reversible), campaign data is
      # deleted from the OSR service.
      sig do
        params(
          tcr_brand_id: String,
          tcr_campaign_id: String,
          age_gated: T::Boolean,
          assigned_phone_numbers_count: Float,
          brand_display_name: String,
          campaign_status:
            Telnyx::TelnyxDownstreamCampaign::CampaignStatus::OrSymbol,
          created_at: String,
          description: String,
          direct_lending: T::Boolean,
          embedded_link: T::Boolean,
          embedded_link_sample: String,
          embedded_phone: T::Boolean,
          failure_reasons: String,
          help_keywords: String,
          help_message: String,
          is_number_pooling_enabled: T::Boolean,
          message_flow: String,
          number_pool: T::Boolean,
          optin_keywords: String,
          optin_message: String,
          optout_keywords: String,
          optout_message: String,
          privacy_policy_link: String,
          sample1: String,
          sample2: String,
          sample3: String,
          sample4: String,
          sample5: String,
          subscriber_optin: T::Boolean,
          subscriber_optout: T::Boolean,
          sub_usecases: T::Array[String],
          terms_and_conditions: T::Boolean,
          terms_and_conditions_link: String,
          updated_at: String,
          usecase: String,
          webhook_failover_url: String,
          webhook_url: String
        ).returns(T.attached_class)
      end
      def self.new(
        # Unique identifier assigned to the brand by the registry.
        tcr_brand_id:,
        # Unique identifier assigned to the campaign by the registry.
        tcr_campaign_id:,
        # Age gated content in campaign.
        age_gated: nil,
        # Number of phone numbers associated with the campaign
        assigned_phone_numbers_count: nil,
        # Display or marketing name of the brand.
        brand_display_name: nil,
        # Campaign status
        campaign_status: nil,
        # Date and time that the brand was created at.
        created_at: nil,
        # Summary description of this campaign.
        description: nil,
        # Direct lending or loan arrangement.
        direct_lending: nil,
        # Does message generated by the campaign include URL link in SMS?
        embedded_link: nil,
        # Sample of an embedded link that will be sent to subscribers.
        embedded_link_sample: nil,
        # Does message generated by the campaign include phone number in SMS?
        embedded_phone: nil,
        # Failure reasons if campaign submission failed
        failure_reasons: nil,
        # Subscriber help keywords. Multiple keywords are comma separated without space.
        help_keywords: nil,
        # Help message of the campaign.
        help_message: nil,
        # Indicates whether the campaign has a T-Mobile number pool ID associated with it.
        is_number_pooling_enabled: nil,
        # Message flow description.
        message_flow: nil,
        # Does campaign utilize pool of phone numbers?
        number_pool: nil,
        # Subscriber opt-in keywords. Multiple keywords are comma separated without space.
        optin_keywords: nil,
        # Subscriber opt-in message.
        optin_message: nil,
        # Subscriber opt-out keywords. Multiple keywords are comma separated without
        # space.
        optout_keywords: nil,
        # Subscriber opt-out message.
        optout_message: nil,
        # Link to the campaign's privacy policy.
        privacy_policy_link: nil,
        # Message sample. Some campaign tiers require 1 or more message samples.
        sample1: nil,
        # Message sample. Some campaign tiers require 2 or more message samples.
        sample2: nil,
        # Message sample. Some campaign tiers require 3 or more message samples.
        sample3: nil,
        # Message sample. Some campaign tiers require 4 or more message samples.
        sample4: nil,
        # Message sample. Some campaign tiers require 5 or more message samples.
        sample5: nil,
        # Does campaign require subscriber to opt-in before SMS is sent to subscriber?
        subscriber_optin: nil,
        # Does campaign support subscriber opt-out keyword(s)?
        subscriber_optout: nil,
        # Campaign sub-usecases. Must be of defined valid sub-usecase types. Use
        # `/registry/enum/usecase` operation to retrieve list of valid sub-usecases
        sub_usecases: nil,
        # Is terms & conditions accepted?
        terms_and_conditions: nil,
        # Link to the campaign's terms and conditions.
        terms_and_conditions_link: nil,
        # Date and time that the brand was last updated at.
        updated_at: nil,
        # Campaign usecase. Must be of defined valid types. Use `/registry/enum/usecase`
        # operation to retrieve usecases available for given brand.
        usecase: nil,
        # Failover webhook to which campaign status updates are sent.
        webhook_failover_url: nil,
        # Webhook to which campaign status updates are sent.
        webhook_url: nil
      )
      end

      sig do
        override.returns(
          {
            tcr_brand_id: String,
            tcr_campaign_id: String,
            age_gated: T::Boolean,
            assigned_phone_numbers_count: Float,
            brand_display_name: String,
            campaign_status:
              Telnyx::TelnyxDownstreamCampaign::CampaignStatus::TaggedSymbol,
            created_at: String,
            description: String,
            direct_lending: T::Boolean,
            embedded_link: T::Boolean,
            embedded_link_sample: String,
            embedded_phone: T::Boolean,
            failure_reasons: String,
            help_keywords: String,
            help_message: String,
            is_number_pooling_enabled: T::Boolean,
            message_flow: String,
            number_pool: T::Boolean,
            optin_keywords: String,
            optin_message: String,
            optout_keywords: String,
            optout_message: String,
            privacy_policy_link: String,
            sample1: String,
            sample2: String,
            sample3: String,
            sample4: String,
            sample5: String,
            subscriber_optin: T::Boolean,
            subscriber_optout: T::Boolean,
            sub_usecases: T::Array[String],
            terms_and_conditions: T::Boolean,
            terms_and_conditions_link: String,
            updated_at: String,
            usecase: String,
            webhook_failover_url: String,
            webhook_url: String
          }
        )
      end
      def to_hash
      end

      # Campaign status
      module CampaignStatus
        extend Telnyx::Internal::Type::Enum

        TaggedSymbol =
          T.type_alias do
            T.all(Symbol, Telnyx::TelnyxDownstreamCampaign::CampaignStatus)
          end
        OrSymbol = T.type_alias { T.any(Symbol, String) }

        TCR_PENDING =
          T.let(
            :TCR_PENDING,
            Telnyx::TelnyxDownstreamCampaign::CampaignStatus::TaggedSymbol
          )
        TCR_SUSPENDED =
          T.let(
            :TCR_SUSPENDED,
            Telnyx::TelnyxDownstreamCampaign::CampaignStatus::TaggedSymbol
          )
        TCR_EXPIRED =
          T.let(
            :TCR_EXPIRED,
            Telnyx::TelnyxDownstreamCampaign::CampaignStatus::TaggedSymbol
          )
        TCR_ACCEPTED =
          T.let(
            :TCR_ACCEPTED,
            Telnyx::TelnyxDownstreamCampaign::CampaignStatus::TaggedSymbol
          )
        TCR_FAILED =
          T.let(
            :TCR_FAILED,
            Telnyx::TelnyxDownstreamCampaign::CampaignStatus::TaggedSymbol
          )
        TELNYX_ACCEPTED =
          T.let(
            :TELNYX_ACCEPTED,
            Telnyx::TelnyxDownstreamCampaign::CampaignStatus::TaggedSymbol
          )
        TELNYX_FAILED =
          T.let(
            :TELNYX_FAILED,
            Telnyx::TelnyxDownstreamCampaign::CampaignStatus::TaggedSymbol
          )
        MNO_PENDING =
          T.let(
            :MNO_PENDING,
            Telnyx::TelnyxDownstreamCampaign::CampaignStatus::TaggedSymbol
          )
        MNO_ACCEPTED =
          T.let(
            :MNO_ACCEPTED,
            Telnyx::TelnyxDownstreamCampaign::CampaignStatus::TaggedSymbol
          )
        MNO_REJECTED =
          T.let(
            :MNO_REJECTED,
            Telnyx::TelnyxDownstreamCampaign::CampaignStatus::TaggedSymbol
          )
        MNO_PROVISIONED =
          T.let(
            :MNO_PROVISIONED,
            Telnyx::TelnyxDownstreamCampaign::CampaignStatus::TaggedSymbol
          )
        MNO_PROVISIONING_FAILED =
          T.let(
            :MNO_PROVISIONING_FAILED,
            Telnyx::TelnyxDownstreamCampaign::CampaignStatus::TaggedSymbol
          )

        sig do
          override.returns(
            T::Array[
              Telnyx::TelnyxDownstreamCampaign::CampaignStatus::TaggedSymbol
            ]
          )
        end
        def self.values
        end
      end
    end
  end
end
